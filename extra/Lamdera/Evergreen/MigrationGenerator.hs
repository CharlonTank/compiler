{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}

module Lamdera.Evergreen.MigrationGenerator where

import Data.Map (Map)
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.List as List
import qualified Data.Text as T
import qualified Data.Name as N
import NeatInterpolation

import qualified AST.Canonical as Can
import qualified Elm.ModuleName as ModuleName
import qualified Elm.Package as Pkg
import qualified Elm.Interface as Interface
import qualified Data.Utf8 as Utf8

import Lamdera
import Lamdera.Types
import qualified Lamdera.Compile
import qualified Ext.ElmFormat
import qualified Ext.Query.Interfaces
import qualified Lamdera.Wire3.Helpers
-- import StandaloneInstances

import Lamdera.Evergreen.MigrationGeneratorHelpers


betweenVersions :: CoreTypeDiffs -> Int -> Int -> String -> IO Text
betweenVersions coreTypeDiffs oldVersion newVersion root = do
    let
        paths = ["src/Evergreen/V" <> show oldVersion <> "/Types.elm", "src/Evergreen/V" <> show newVersion <> "/Types.elm"]
        moduleNameString = "Evergreen.V" <> show newVersion <> ".Types"

    Lamdera.Compile.makeDev root paths

    res <- withCurrentDirectory root $ do
        interfaces <- Ext.Query.Interfaces.all paths
        case Map.lookup (N.fromChars moduleNameString) interfaces of
          Just interface ->
            generateFor coreTypeDiffs oldVersion newVersion interfaces (interfaces Map.! (N.fromChars $ "Evergreen.V" <> show newVersion <> ".Types"))

          Nothing ->
            error $ "Fatal: could not find the module `" <> moduleNameString <> "`, please report this issue in Discord with your project code."

    Ext.ElmFormat.formatOrPassthrough res
    -- res2 <- Ext.ElmFormat.format res
    -- case res2 of
    --   Right x -> pure x
    --   Left err -> error (T.unpack err)


generateFor :: CoreTypeDiffs -> Int -> Int -> Interfaces -> Interface.Interface -> IO Text
generateFor coreTypeDiffs oldVersion newVersion interfaces iface_Types = do
  let
    moduleName :: ModuleName.Canonical
    moduleName = (ModuleName.Canonical (Pkg.Name "author" "project") (N.fromChars $ "Evergreen.V" <> show newVersion <> ".Types"))

    migrations :: [(N.Name, Migration)]
    migrations =
      coreTypeDiffs
        & fmap (\(t, oldHash, newHash) ->
            (t, coreTypeMigration (oldHash /= newHash) oldVersion newVersion interfaces moduleName t iface_Types)
        )
        -- & debugHaskell "all migration definitions"
        -- & foldl (\acc (t, ft) -> mergeMigrationDefinitions acc ft) Map.empty
        -- & debugHaskell "efts"

    imports = migrations
      & fmap snd
      & allImports
      -- a little weird but ensures current version of types, our entry point, is added to final migration imports...
      & Set.insert moduleName
      & importsToText
      & (++) additionalImports
      & List.sort
      & List.nub
      & T.intercalate "\n"


    additionalImports :: [Text]
    additionalImports = ["import Lamdera.Migrations exposing (..)"]

    coreMigrations = migrations & fmap (migrationDef . snd)

    subMigrations = migrations & fmap (migrationTopLevelDefs . snd) & mergeAllMigrationDefinitions & allMigrations

    output =
      [ (T.concat [ "module Evergreen.Migrate.V", show_ newVersion, " exposing (..)" ])
      , helpfulInformation
      , imports
      ] ++ coreMigrations ++ [subMigrations]


  output & T.intercalate "\n\n" & pure



helpfulInformation :: Text
helpfulInformation =
  -- @TODO currently silly hack, but the 'Unimplemented' keyword is naively used to check if there are
  -- any pending migrations... but that means we can't use that word in comments, so we use the utf8 substitute
  -- character trick in the `Unimplementеd` text below which won't match on the basic string search.
  -- In future the better resolution would be to detect the Unimplemented keyword in the AST, so the user
  -- can just comment stuff out but leave it for record.
  [text|
    {-| This migration file was automatically generated by the lamdera compiler.

    It includes:

      - A migration for each of the 6 Lamdera core types that has changed
      - A function named `migrate_ModuleName_TypeName` for each changed/custom type

    Expect to see:

      - `Unimplementеd` values as placeholders wherever I was unable to figure out a clear migration path for you
      - `@NOTICE` comments for things you should know about, i.e. new custom type constructors that won't get any
        value mappings from the old type by default

    You can edit this file however you wish! It won't be generated again.

    See <https://dashboard.lamdera.com/docs/evergreen> for more info.
    -}
  |]


coreTypeMigration :: Bool -> Int -> Int -> Interfaces -> ModuleName.Canonical -> N.Name -> Interface.Interface -> Migration
coreTypeMigration typeDidChange oldVersion newVersion interfaces newModule typeName interface = do
  let
    recursionIdentifier :: (ModuleName.Canonical, N.Name)
    recursionIdentifier = (newModule, typeName)

    recursionSet :: RecursionSet
    recursionSet = Set.singleton recursionIdentifier

    identifier :: TypeIdentifier
    identifier = asIdentifier_ recursionIdentifier

    t :: Text
    t = nameToText typeName

    newModuleName :: Text
    newModuleName = newModule & canModuleName & N.toText

    oldModuleName :: Text
    oldModuleName = asOldModuleName (canModuleName newModule) newVersion oldVersion & nameToText

    migrationWrapper :: Text -> Text
    migrationWrapper migration = do
      (T.concat
        ["\n", (lowerFirstLetter_ t), " : ", oldModuleName, ".", t, " -> ", migrationTypeForType typeName , " ", newModuleName, ".", t, " ", newModuleName, ".", msgForType typeName, "\n"
        , (lowerFirstLetter_ $ nameToText typeName), " old = ", migration
        ])

  if typeDidChange
    then
      case findDef (canModuleName newModule) typeName interfaces of
        Just (Alias alias) -> do
          let
            diffableAlias = aliasToFt oldVersion newVersion newModule identifier typeName interfaces recursionSet alias "old"
            (MigrationNested migrationImpl imps subft migrationName) = diffableAlias
            migration = T.concat ["\n    ", migrationWrapperForType typeName, " ( ", migrationImpl, " old, Cmd.none )"]
          (MigrationNested (migrationWrapper migration) imps (subft & addImports newModule imps) migrationName)

        Just (Union union) -> do
          let
            diffableUnion = migrateUnion oldVersion newVersion newModule identifier typeName interfaces recursionSet [] union []
            (MigrationNested migrationImpl imps subft migrationName) = diffableUnion
            migration = T.concat ["\n    ", migrationWrapperForType typeName, " ( ", migrationImpl, " old, Cmd.none )"]
          (MigrationNested (migrationWrapper migration) imps (subft & addImports newModule imps) migrationName)

        Nothing ->
          error $ concat [ "Tried to generate a migration for core type ", N.toChars typeName, ", but I couldn't find it defined in Types.elm" ]
    else
      (MigrationNested (migrationWrapper (unchangedForType typeName)) Set.empty Map.empty "")


-- A top level Custom Type definition i.e. `type Herp = Derp ...`
migrateUnion :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> [(N.Name, Can.Type)] -> Can.Union -> [Can.Type] -> Migration
migrateUnion oldVersion newVersion scope identifier@(author, pkg, newModule, tipe) typeName interfaces recursionSet tvarMap newUnion params =
  let
    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    tipeOld :: Maybe TypeDef
    tipeOld = findDef oldModuleName typeName interfaces
  in
  case tipeOld of
  Nothing        ->
    xMigrationNested ("Unimplemented -- I couldn't find an old type named `" <> N.toText typeName <> "`. I need you to write this migration.", Set.empty, Map.empty, "")
  Just (Alias a) ->
    xMigrationNested ("Unimplemented -- `" <> N.toText typeName <> "` was a type alias, but now it's a custom type. I need you to write this migration.", Set.empty, Map.empty, "")
  Just (Union oldUnion) ->
    migrateUnion_ author pkg oldUnion newUnion params tvarMap oldVersion newVersion typeName newModule identifier oldModuleName interfaces recursionSet scope


-- catcher x =
--   x


migrateUnion_ :: Pkg.Author -> Pkg.Project -> Can.Union -> Can.Union -> [Can.Type] -> [(N.Name, Can.Type)] -> Int -> Int -> N.Name -> N.Name -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> ModuleName.Canonical -> Migration
migrateUnion_ author pkg oldUnion newUnion params tvarMap oldVersion newVersion typeName newModule identifier oldModuleName interfaces recursionSet scope =
  let
    oldModuleNameCanonical :: ModuleName.Canonical
    oldModuleNameCanonical =
      (ModuleName.Canonical (Pkg.Name "author" "project") oldModuleName)

    tvarMapNew :: [(N.Name, Can.Type)]
    tvarMapNew =
      params
        & zip (Can._u_vars newUnion)

    newTvars :: [Text]
    newTvars =
      params
        & zip (Can._u_vars newUnion)
        & fmap (N.toText . fst)

    oldTvars :: [Text]
    oldTvars =
      params
        & zip (Can._u_vars oldUnion)
        & fmap (N.toText . fst)


    -- oldTvars :: [Text]
    -- oldTvars =
    --   Can._u_vars oldUnion
    --     -- & debugHaskell "_u"
    --     & fmap (Can.TVar)
    --     & fmap (Lamdera.Wire3.Helpers.resolveTvars tvarMap)
    --   -- resolveTvars tvarMap
    --   -- params
    --   --   & zip ()
    --     -- & fmap (N.toText . fst)
    --     & fmap qualifiedTypeName
    --     -- & T.intercalate " "


    paramMigrations :: [Migration]
    paramMigrations =

      -- @TODO do we need to use oldParams here? Maybe not as this is the def migrator, and the actual
      -- value migratons will get caught in the actual constructor migrations?
      zip (tvarResolvedParams params tvarMap) (tvarResolvedParams params tvarMapNew)
        & imap (\i (paramOld, paramNew) ->
          canToMigration oldVersion newVersion scope interfaces recursionSet paramNew (Just paramOld) tvarMap ("p" <> show_ i)
        )
        -- & debugHaskell "paramMigrations"
        -- & (\v -> if length v /= 0 then catcher v else v )


      -- If we do need to migrate params here, it would probably be something like:
      -- let
      --   oldParams = error "todo used oldParams"
      --   newParams = error "todo used newParams"
      -- in
      -- zipFull oldParams newParams
      --   & imap (\i (paramOldM, paramNewM) ->
      --     migrateParam i paramOldM paramNewM interfaces tvarMap recursionSet localScope newVersion oldVersion
      --   )

    paramMigrationTextsCombined :: Text
    paramMigrationTextsCombined =
      paramMigrations
        & fmap migrationDef
        & T.intercalate " "

    usageImports :: Set.Set ModuleName.Canonical
    usageImports = paramMigrations & allImports & Set.insert oldModuleNameCanonical

    paramMigrationDefinitions :: MigrationDefinitions
    paramMigrationDefinitions = paramMigrations & allMigrationDefinitions

    localScope :: ModuleName.Canonical
    localScope =
      (ModuleName.Canonical (Pkg.Name author pkg) newModule)

    oldConstructorsMigrations :: [Migration]
    oldConstructorsMigrations = genOldConstructorMigrationDefinitions oldModuleName moduleScope typeName interfaces tvarMap recursionSet localScope newVersion oldVersion newUnion oldUnion

    imports :: ElmImports
    imports = oldConstructorsMigrations & foldl (\acc (MigrationNested st imps ft migrationName) -> mergeImports acc imps) Set.empty

    oldConstructorsMigrationDefinitions :: MigrationDefinitions
    oldConstructorsMigrationDefinitions =
      oldConstructorsMigrations & foldl (\acc (MigrationNested st imps ft migrationName) -> mergeMigrationDefinitions acc ft) Map.empty

    moduleScope :: Text
    moduleScope = nameToText newModule <> "."

    moduleScopeOld :: Text
    moduleScopeOld = nameToText oldModuleName <> "."

    migrationName :: Text
    migrationName = migrationNameUnderscored newModule oldVersion newVersion typeName

    migration :: Text
    migration = migrationName <> " " <> paramMigrationTextsCombined -- <> "<!2>"


    paramMigrationPairs = zip oldTvars newTvars

    paramMigrationFnsTypeSig :: [Text]
    paramMigrationFnsTypeSig =
      paramMigrationPairs
        & fmap (\(oldT, newT) -> T.concat [ "(", oldT, "_old -> ", newT, "_new)" ] )

    paramMigrationVars :: Text
    paramMigrationVars =
      paramMigrationPairs
        & fmap (\(oldT, newT) -> T.concat [ "migrate_", oldT ] )
        & T.intercalate " "

    migrationTypeSignature :: Text
    migrationTypeSignature = T.concat
      [ paramMigrationFnsTypeSig & T.intercalate " -> " & suffixIfNonempty " -> "
      , " "
      , oldModuleName & N.toText, ".", typeName & N.toText
      , " "
      , oldTvars & fmap (\tvar -> T.concat [tvar, "_old"]) & T.intercalate " "
      , " -> "
      , newModule & N.toText, ".", typeName & N.toText
      , " "
      , newTvars & fmap (\tvar -> T.concat [tvar, "_new"]) & T.intercalate " "
      ]

    constructorCaseMigrations :: Text
    constructorCaseMigrations =
      oldConstructorsMigrations
        & fmap migrationDef
        & flip (++) (newConstructorWarnings typeName moduleScopeOld newUnion oldUnion newVersion)
        & T.concat

    newConstructorWarnings :: N.Name -> Text -> Can.Union -> Can.Union -> Int -> [Text]
    newConstructorWarnings typeName moduleScope newUnion oldUnion newVersion =
      Can._u_alts newUnion
        & filterMap (\(Can.Ctor newConstructor index int newParams) -> do
          case Can._u_alts oldUnion & List.find (\(Can.Ctor oldConstructor _ _ _) -> newConstructor == oldConstructor ) of
            Nothing ->
              let params =
                    if length newParams > 0
                      then " " <> (T.intercalate " " (fmap asTypeName newParams))
                      else ""
              in
              -- This constructor is missing a match in the old type, warn the user this new constructor exists
              Just $ T.concat [
                "        {- @NOTICE `", N.toText newConstructor, params, "` was added in V", show_ newVersion, ".\n",
                "        This is just a reminder in case migrating some subset of the old data to this new value was important.\n",
                "        See https://lamdera.com/tips/modified-custom-type for more info.\n",
                "        -}\n"
                ]
            Just _ ->
              -- This constructor has a match in the old type, so skip it
              Nothing
        )
        & (\notices ->
              if length notices > 0 then
                ["    notices ->\n" <>
                "        " <> T.concat notices <> "\n" <>
                "        Unimplemented"]
              else
                []
          )
  in
  -- debug $
  xMigrationNested
  ( migration
  , usageImports
  , (Map.singleton (moduleKey identifier) $
      MigrationDefinition
        { imports = imports
        , migrations = Map.singleton migrationName $ T.concat
            [ migrationName, " : ", migrationTypeSignature, "\n"
            , [ migrationName, paramMigrationVars, " old =\n" ] & T.intercalate " "
            , "  case old of\n"
            , constructorCaseMigrations
            ]
        })
      & mergeMigrationDefinitions oldConstructorsMigrationDefinitions
      & mergeMigrationDefinitions paramMigrationDefinitions
  , ""
  )


genOldConstructorMigrationDefinitions :: N.Name -> Text -> N.Name -> Interfaces -> [(N.Name, Can.Type)] -> RecursionSet -> ModuleName.Canonical -> Int -> Int -> Can.Union -> Can.Union -> [Migration]
genOldConstructorMigrationDefinitions oldModuleName moduleScope typeName interfaces tvarMap recursionSet localScope newVersion oldVersion newUnion oldUnion =
  Can._u_alts oldUnion
    & fmap (\(Can.Ctor oldConstructor index int oldParams) ->
      -- For each OLD constructor type param
      genOldConstructorFt oldModuleName moduleScope typeName interfaces tvarMap recursionSet localScope newVersion oldVersion newUnion oldUnion oldConstructor oldParams

    )

migrateParam :: Int -> Maybe Can.Type -> Maybe Can.Type -> Interfaces -> [(N.Name, Can.Type)] -> RecursionSet -> ModuleName.Canonical -> Int -> Int -> Migration
migrateParam i paramOldM paramNewM interfaces tvarMap recursionSet localScope newVersion oldVersion =
  case (paramOldM, paramNewM) of
    (Just paramOld, Just paramNew) ->
      let ft@(MigrationNested migration imps subft migrationName) =
            canToMigration oldVersion newVersion localScope interfaces recursionSet paramNew (Just paramOld) tvarMap ("p" <> show_ i)

          appliedMigration =
            if isTvar paramOld then
              case paramOld of
                Can.TVar name ->
                  T.concat ["( migrate_", N.toText name, " p", show_ i, ")"]
                _ -> "impossible"
            else if paramOld == paramNew then
              T.concat ["p", show_ i]
            else if isAnonymousRecord paramOld then
              migration
            else if isUserDefinedType_ paramOld then
              T.concat ["(p", show_ i, " |> ", migration, ")"]
            else
              T.concat ["(p", show_ i, " |> ", migration, ")"]

      in
      xMigrationNested (appliedMigration, imps, subft, "")

    (Just paramOld, Nothing) ->
      xMigrationNested ("\n-- warning: old variant didn't get mapped to anything, check this is what you want\n", Set.empty, Map.empty, "")

    (Nothing, Just paramNew) ->
      xMigrationNested ("(Debug.todo \"this new variant needs to be initialised!\")", Set.empty, Map.empty, "")

    _ -> error "impossible, zip produced a value without any contents"


genOldConstructorFt oldModuleName moduleScope typeName interfaces tvarMap recursionSet localScope newVersion oldVersion newUnion oldUnion oldConstructor oldParams =
  let
    newCtorM :: Maybe Can.Ctor
    newCtorM = Can._u_alts newUnion & List.find (\(Can.Ctor newConstructor _ _ _) -> newConstructor == oldConstructor )

    migration_ :: Migration
    migration_ =
      case newCtorM of
      Just (Can.Ctor newConstructor _ _ newParams) ->
        let
            paramMigrations :: [Migration]
            paramMigrations =
              zipFull oldParams newParams
                & imap (\i (paramOldM, paramNewM) ->
                  migrateParam i paramOldM paramNewM interfaces tvarMap recursionSet localScope newVersion oldVersion
                )

            fullMigration =
              xMigrationNested ( if List.length oldParams > 0 then
                  let migration =
                        paramMigrations
                          & fmap migrationDef
                          & (\paramMigrations -> T.concat [ moduleScope, N.toText newConstructor, " ", (paramMigrations & T.intercalate " ") ])
                  in
                  T.concat
                      [ "    ", N.toText oldModuleName, ".", N.toText oldConstructor, " ", (imap (\i _ -> "p" <> show_ i) oldParams & T.intercalate " ")
                      , " -> \n"
                      , migration & T.lines & fmap (\v -> T.concat ["        ", v ]) & T.unlines
                      , "\n"
                      ]
                else
                  T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructor, " -> ", moduleScope, N.toText newConstructor, "\n"]
              , paramMigrations
                  & fmap migrationImports
                  & mergeAllImports
              , paramMigrations
                  & fmap migrationTopLevelDefs
                  & mergeAllMigrationDefinitions
              , ""
              )
        in
        fullMigration

      Nothing ->
        let
          oldConstructorRemovedMessage :: Text
          oldConstructorRemovedMessage =
            T.concat [
              " ->\n",
              "           {- `", N.toText oldConstructor, "` was removed or renamed in V", show_ newVersion, " so I couldn't figure out how to migrate it.\n",
              "           I need you to decide what happens to this ", N.toText oldModuleName, ".", N.toText oldConstructor, " value in a migration.\n",
              "           See https://lamdera.com/tips/modified-custom-type for more info.\n",
              "           -}\n",
              "           Unimplemented\n"
            ]
        in
        xMigrationNested ( -- No old constructor with same name, so this is a new/renamed constructor
          if List.length oldParams > 0
            then
              T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructor, " ", (imap (\i _ -> "p" <> show_ i) oldParams & T.intercalate " "), oldConstructorRemovedMessage]
            else
              T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructor, oldConstructorRemovedMessage]
        , Set.empty
        , Map.empty
        , ""
        )
  in
  migration_


-- A top level Alias definition i.e. `type alias ...`
aliasToFt :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> Can.Alias -> Text -> Migration
aliasToFt oldVersion newVersion scope identifier@(author, pkg, newModule, _) typeName interfaces recursionSet alias@(Can.Alias tvars tipe) oldValueRef =
  let
    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    tipeOldM :: Maybe TypeDef
    tipeOldM = findDef oldModuleName typeName interfaces

  in
  case tipeOldM of
    Nothing               ->
      xMigrationNested ("Unimplemented -- I couldn't find an old type named `" <> N.toText typeName <> "`. I need you to write this migration.", Set.empty, Map.empty, "")
    Just (Union oldUnion) ->
      xMigrationNested ("Unimplemented -- `" <> N.toText typeName <> "` was a custom type, but now it's a type alias. I need you to write this migration.", Set.empty, Map.empty, "")
    Just (Alias aliasOld@(Can.Alias tvarsOld tipeOld)) ->
      migrateAlias oldVersion newVersion scope identifier typeName interfaces recursionSet alias aliasOld oldModuleName oldValueRef


-- A top level Alias definition i.e. `type alias ...`
migrateAlias :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> Can.Alias -> Can.Alias -> N.Name -> Text -> Migration
migrateAlias oldVersion newVersion scope identifier@(author, pkg, newModule, _) typeName interfaces recursionSet (Can.Alias tvarsNew tipe) (Can.Alias tvarsOld tipeOld) oldModuleName oldValueRef =
  let
    (MigrationNested subt imps subft migrationName) = canToMigration oldVersion newVersion scope interfaces recursionSet tipe (Just tipeOld) [] oldValueRef

    typeScope =
      if moduleName == scope then
        ""
      -- else if isUserType identifier then
      --   nameToText newModule <> "."
      else
        T.concat [nameToText newModule, "."]

    moduleName = (ModuleName.Canonical (Pkg.Name author pkg) newModule)

    migration =
      if tipe == tipeOld then
        "ModelUnchanged"
      else
        subt

    newModuleName = newModule & N.toText

    migrationName_ :: Text
    migrationName_ = migrationNameUnderscored newModule oldVersion newVersion typeName
  in
  xMigrationNested
  ( migrationName_
  , imps
  , (Map.singleton (moduleKey identifier) $
      MigrationDefinition
        { imports = imps
        , migrations = Map.singleton
            (lowerFirstLetter_ $ nameToText typeName)
            (T.concat
              ["\n", migrationName_, " : ", nameToText oldModuleName, ".", nameToText typeName, " -> ", newModuleName, ".", nameToText typeName, "\n"
              , migrationName_, " old = ", migration
              ])
        })
      & mergeMigrationDefinitions subft
  , migrationName_
  )


canToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
canToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef =

  -- let !x = debugHaskell "canToMigration" (tipeOldM, tipe)
  -- in
  case tipe of
    Can.TType moduleName name params ->
      typeToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef

    Can.TAlias moduleName name tvarMap_ aliasType ->
      canAliasToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef

    Can.TRecord newFields isPartial ->
      recordToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef

    Can.TTuple t1 t2 mt3 ->
      let
        (MigrationNested subt imps subft migrationName) =
          canToMigration oldVersion newVersion scope interfaces recursionSet t1 tipeOldM tvarMap oldValueRef
        (MigrationNested subt2 imps2 subft2 migrationName2) =
          canToMigration oldVersion newVersion scope interfaces recursionSet t2 tipeOldM tvarMap oldValueRef
      in
      case mt3 of
        Just t3 ->
          let
            (MigrationNested subt3 imps3 subft3 migrationName3) =
              canToMigration oldVersion newVersion scope interfaces recursionSet t3 tipeOldM tvarMap oldValueRef
          in
          xMigrationNested (T.concat ["(", subt, ", ", subt2, ", ", subt3, ")"], mergeAllImports [imps,imps2,imps3], mergeAllMigrationDefinitions [subft,subft2,subft3], "")

        Nothing ->
          xMigrationNested (T.concat ["(", subt, ", ", subt2, ")"], mergeImports imps imps2, mergeMigrationDefinitions subft subft2, "")
      -- DTuple (canToMigration oldVersion newVersion scope interfaces recursionSet t1 tvarMap) (canToMigration oldVersion newVersion scope interfaces recursionSet t2 tvarMap)

    Can.TUnit ->
      xMigrationNested ("()", Set.empty, Map.empty, "")

    Can.TVar name ->
      xMigrationNested ("migrate_" <> N.toText name, Set.empty, Map.empty, "")

    Can.TLambda _ _ ->
      error "Fatal: impossible function type! Please report this gen issue."
      -- ("XXXXXX TLambda", Set.empty, Map.empty)
      -- DError $ "must not contain functions"


canAliasToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
canAliasToMigration oldVersion newVersion scope interfaces recursionSet tipe@(Can.TAlias moduleName name tvarMap_ aliasType) tipeOldM tvarMap oldValueRef =
  let
    module_ =
      case moduleName of
        (ModuleName.Canonical (Pkg.Name author pkg) module_) -> module_

    newModule = module_

    identifier = asIdentifier_ (moduleName, name)

    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    typeName = name
  in
  case aliasType of
    Can.Holey cType ->
      case tipeOldM of
        Just (tipeOld@(Can.TAlias moduleName name tvarMapOld aliasType)) ->
          let
            usageParamFts :: [Migration]
            usageParamFts =
              tvarMap_
                & fmap (\(n, paramType) ->
                  -- @TODO are we sure we don't need oldParam setup here? Need to come up with a test example if we do.
                  let oldParamType = Nothing
                  in
                  canToMigration oldVersion newVersion scope interfaces recursionSet paramType oldParamType tvarMap_ oldValueRef
                )

            usageParamNames :: Text
            usageParamNames =
              usageParamFts
                & fmap migrationDef
                & T.intercalate " "

            usageParamImports :: ElmImports
            usageParamImports =
              usageParamFts
                & fmap migrationImports
                & mergeAllImports

            newTvars :: [Text]
            newTvars =
              tvarMap_
                & fmap (N.toText . fst)
                -- & T.intercalate " "

            oldTvars :: [Text]
            oldTvars =
              tvarMapOld
                & fmap (N.toText . fst)


            (MigrationNested subt imps subft migrationName_) :: Migration =
              let
                !_ = debugHaskell "canAliasToMigration" (typeName, res)
                paramPairs =
                  zipWith (\(n1,t1) (n2,t2) -> (n1, t1, t2)) tvarMapOld tvarMap_

                res = canToMigration oldVersion newVersion moduleName interfaces recursionSet cType (Just tipeOld) tvarMapOld oldValueRef
              in
              res

            typeScope =
              if moduleName == scope then
                ""
              -- else if isUserType identifier then
              --   nameToText module_ <> "."
              else
                T.concat [nameToText module_, "."]

            debugIden = "" -- <> "<ah>"

            scopeImports =
              -- if moduleName == scope then
              --   usageParamImports
              -- else
                usageParamImports & Set.insert moduleName

            migrationName :: Text
            migrationName = migrationNameUnderscored newModule oldVersion newVersion name

            paramMigrationPairs = zip oldTvars newTvars

            paramMigrationFnsTypeSig :: [Text]
            paramMigrationFnsTypeSig =
              paramMigrationPairs
                & fmap (\(oldT, newT) -> T.concat [ "(", oldT, "_old -> ", newT, "_new)" ] )

            paramMigrationVars :: Text
            paramMigrationVars =
              paramMigrationPairs
                & fmap (\(oldT, newT) -> T.concat [ "migrate_", oldT ] )
                & T.intercalate " "

            migrationTypeSignature :: Text
            migrationTypeSignature = T.concat
              [ paramMigrationFnsTypeSig & T.intercalate " -> " & suffixIfNonempty " -> "
              , " "
              , oldModuleName & N.toText, ".", typeName & N.toText
              , " "
              , oldTvars & fmap (\tvar -> T.concat [tvar, "_old"]) & T.intercalate " "
              , " -> "
              , newModule & N.toText, ".", typeName & N.toText
              , " "
              , newTvars & fmap (\tvar -> T.concat [tvar, "_new"]) & T.intercalate " "
              ]

            typeDef =
              if isUserDefinedType_ cType then
                -- if length tvarMap_ > 0 then
                --     [migrationName <> " old = " <> subt]
                -- else
                Map.singleton migrationName $ T.concat
                  [ migrationName, " : ", migrationTypeSignature, "\n"
                  , migrationName, " ", paramMigrationVars, " ", oldValueRef, " = ", subt
                  ]

              else
                -- ["-- no migration for primitive: " <> N.toText name ]
                Map.empty

            thing =
              (Map.singleton (moduleNameKey moduleName) $
                MigrationDefinition
                  { imports = imps
                  , migrations = typeDef
                  }
              )
                & mergeMigrationDefinitions subft
                & mergeMigrationDefinitions (mergeAllMigrationDefinitions (fmap migrationTopLevelDefs usageParamFts))


            migration =
              if length tvarMap_ > 0 then
                T.concat ["(", migrationName, " ", usageParamNames, ")"] -- <> "<!2>"
              else
                migrationName -- <> "<!3>"

          in

          if tipeOld == tipe then
            xMigrationNested ("SAMETYPES", scopeImports, thing, "")
          else
            xMigrationNested (
              -- debugIden <> "🔵" <>
              migration
              -- "migrateeee" <>
              -- if length tvarMap_ > 0 then
              --   "(" <> typeScope <> N.toText name <> " " <> usageParamNames <> ")"
              -- else
              --   typeScope <> N.toText name
            , scopeImports
            , thing
            , ""
            )

        Just _ ->
          xMigrationNested ("Unimplemented -- `" <> N.toText typeName <> "` was a concrete type, but now it's a type alias. I need you to write this migration.", Set.empty, Map.empty, "")

        Nothing ->
          xMigrationNested (T.concat ["Unimplemented -- I couldn't find an old type named `", N.toText typeName, "`. I need you to write this migration." ], Set.empty, Map.empty, "")


    Can.Filled cType ->
      -- @TODO hypothesis...
      -- If an alias is filled, then it can't have any open holes within it either?
      -- So we can take this opportunity to reset tvars to reduce likeliness of naming conflicts?
      let
        (MigrationNested subt imps subft migrationName) = canToMigration oldVersion newVersion moduleName interfaces recursionSet cType tipeOldM [] oldValueRef

        debugIden = "" -- <> "<af>"
      in
      xMigrationNested (
        debugIden <> "🔴" <>
        if module_ == (canModuleName scope) then
          N.toText name
        else if isUserType identifier then
          T.concat [nameToText module_, "."]
        else
          T.concat [nameToText module_, ".", N.toText name]
      , imps
      , subft
      , ""
      )


recordToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
recordToMigration oldVersion newVersion scope interfaces recursionSet tipe@(Can.TRecord newFields isPartial) tipeOldM tvarMap oldValueRef =
  case isPartial of
    Just whatIsThis ->
      xMigrationNested ("ERROR TRecord, please report this!", Set.empty, Map.empty, "")
      -- DError "must not contain partial records"

    Nothing ->
      let
        fieldMapOld :: Map N.Name Can.FieldType
        fieldMapOld =
          case tipeOldM of
            Just tipeOld ->
              case Lamdera.Wire3.Helpers.resolveFieldMap tipeOld tvarMap of
                Just fields -> fields
                Nothing -> Map.empty
            _ -> Map.empty

        fields :: [(Text, Migration)]
        fields =
          newFields
            & Map.toList
            -- Restore user's field code-ordering to keep types looking familiar
            & List.sortOn (\(name, (Can.FieldType index ftipe)) -> index)
            & fmap (\(name, (Can.FieldType index ftipe)) ->
                case Map.lookup name fieldMapOld of
                  Just (Can.FieldType index_ ftipeOld) ->
                    if isEquivalentElmType name ftipeOld ftipe then
                      (N.toText name, xMigrationNested (T.concat[ oldValueRef, ".", N.toText name], Set.empty, Map.empty, ""))
                    else
                      -- debugHaskellPassDiffWhen (name == "unchangedAllTypes") "these types are unequal" (ftipeOld, ftipe) $
                      if isAnonymousRecord ftipe
                        then
                          -- In order to deal with anonymous records inline, we have to change
                          -- the name of the value to avoid shadowing the `old.` ref.
                          let
                            readMaybeInt :: Text -> Maybe Int
                            readMaybeInt = readMaybeText

                            -- For every additional anonymous nesting, bump the reference number
                            recname :: Text
                            recname =
                              case oldValueRef of
                                "old" -> "rec"
                                _ ->
                                  oldValueRef
                                    & T.replace "rec" ""
                                    & readMaybeInt
                                    & withDefault (0 :: Int)
                                    & (+) 1
                                    & show_
                                    & (<>) "rec"

                            (MigrationNested st imps ft migrationName) = recordToMigration oldVersion newVersion scope interfaces recursionSet ftipe (Just ftipeOld) tvarMap recname
                          in
                          ( N.toText name
                          , xMigrationNested
                            ( T.concat [oldValueRef, ".", N.toText name, " |> (\\", recname, " -> ", st, ")"]
                            , imps, ft, ""
                            )
                          )
                        else
                          let
                            (MigrationNested st imps ft migrationName) =
                              canToMigration oldVersion newVersion scope interfaces recursionSet ftipe (Just (ftipeOld)) tvarMap oldValueRef
                            -- case ftipe of
                          in
                          ( N.toText name
                          , xMigrationNested
                            ( T.concat [oldValueRef, ".", N.toText name, " |> ", st ]
                            , imps, ft, ""
                            )
                          )

                  Nothing ->
                    -- This field did not exist in the old version. We need an init!
                    let (MigrationNested st imps ft migrationName) = canToMigration oldVersion newVersion scope interfaces recursionSet ftipe Nothing tvarMap oldValueRef
                    in
                    ( N.toText name, xMigrationNested (T.concat["Unimplemented -- Type `", qualifiedTypeName ftipe, "` was added in V", show_ newVersion, ". I need you to set a default value."], imps, ft, "") )
            )
            & (\v -> v ++ missingFields)

        missingFields :: [(Text, Migration)]
        missingFields =
          fieldMapOld
            & Map.toList
            & filterMap (\(name, (Can.FieldType index tipe)) ->
              case Map.lookup name newFields of
                Just (Can.FieldType index_ tipeOld) ->
                  Nothing
                Nothing ->
                  Just ( N.toText name,
                    xMigrationNested (T.concat["Unimplemented -- Field of type `", qualifiedTypeName tipe, "` was removed in V", show_ newVersion, ". I need you to do something with the `", oldValueRef, ".", N.toText name, "` value if you wish to keep the data, then remove this line."]
                    , Set.empty
                    , Map.empty
                    , ""
                    )
                  )
            )

        fieldsFormatted :: Text
        fieldsFormatted =
          fields
            & fmap (\(fieldname, (MigrationNested st imps ft migrationName)) -> fieldname <> " = " <> st)
            & T.intercalate "\n    , "

        imports :: ElmImports
        imports =
          fields
            & foldl (\acc (name, (MigrationNested st imps ft migrationName)) -> mergeImports acc imps) Set.empty

        mergedFt :: MigrationDefinitions
        mergedFt =
          fields
            & foldl (\acc (name, (MigrationNested st imps ft migrationName)) -> mergeMigrationDefinitions acc ft) Map.empty
            & addImports scope imports

        result :: Migration
        result =
          xMigrationNested ("\n    { " <> fieldsFormatted <> "\n    }"
          , imports
          , mergedFt
          , ""
          )
      in
      result


typeToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
typeToMigration oldVersion newVersion scope interfaces recursionSet tipe@(Can.TType moduleName name params) tipeOldM tvarMap oldValueRef =
  let
    recursionIdentifier :: (ModuleName.Canonical, N.Name)
    recursionIdentifier = (moduleName, name)

    newRecursionSet :: Set.Set (ModuleName.Canonical, N.Name)
    newRecursionSet = Set.insert recursionIdentifier recursionSet

    identifier :: TypeIdentifier
    identifier = asIdentifier tipe

    typeName :: Text
    typeName = asTypeName tipe

    kernelError :: Migration
    kernelError =
      case identifier of
        (author, pkg, module_, typeName) ->
          xMigrationNested
            ( T.concat ["Kernel error: must not contain kernel type `", show_ tipe, "` from ", show_ author, "/", show_ pkg, ":", nameToText module_ ]
            , Set.empty
            , Map.empty
            , ""
            )

    moduleNameRaw :: N.Name
    moduleNameRaw = canModuleName moduleName

    migrateSingleParamCollection :: Migration
    migrateSingleParamCollection =
      case tipeOldM of
        Just tipeOld ->
          case tipeOld of
            Can.TType _ _ paramsOld -> -- @WARNING MUST BE SAME COLLECTION TYPE...?
              zipFull paramsOld params & (\p ->
                case p of
                  (Just p0o,Just p0):[] ->
                    let
                      (MigrationNested migration1 imps1 subft1 migrationName1) = (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMap "p0")

                      migration = case (p0o == p0) of
                        (True) -> "" -- No migration necessary
                        (False) ->
                          if migration1 == ""
                            then
                              T.concat [ typeName, ".map Unimplemented", " -- Type changed from `", typeName, " ", qualifiedTypeName p0o, "` to `", typeName, " ", qualifiedTypeName p0, "`\n" ]
                            else
                              T.concat [ typeName, ".map ", migration1 ]
                    in
                    xMigrationNested (migration, imps1 & Set.insert moduleName, subft1, "")
                  _ ->
                    error $ T.unpack $ T.concat ["migrateSingleParamCollection: impossible multi-param ", typeName, "! Please report this gen issue."]
              )
            _ -> error $ T.unpack $ T.concat ["migrateSingleParamCollection: non-matching TType in ", typeName, " gen:\nold:", show_ tipeOld, "\nnew:", show_ tipe]

        Nothing ->
          xMigrationNested (T.concat ["Unimplemented -- This ", typeName, " type has changed to something else"], Set.empty, Map.empty, "")

  in
  if (Set.member recursionIdentifier recursionSet) then
    handleSeenRecursiveType oldVersion newVersion scope identifier interfaces recursionSet tipe tipeOldM tvarMap oldValueRef
  else
  case identifier of
    ("elm", "core", "String", "String") -> xMigrationNested ("", Set.empty, Map.empty, "")
    ("elm", "core", "Basics", "Int") ->    xMigrationNested ("", Set.empty, Map.empty, "")
    ("elm", "core", "Basics", "Float") ->  xMigrationNested ("", Set.empty, Map.empty, "")
    ("elm", "core", "Basics", "Bool") ->   xMigrationNested ("", Set.empty, Map.empty, "")
    ("elm", "core", "Basics", "Order") ->  xMigrationNested ("", Set.empty, Map.empty, "")
    ("elm", "core", "Basics", "Never") ->  xMigrationNested ("", Set.empty, Map.empty, "")
    ("elm", "core", "Char", "Char") ->     xMigrationNested ("", Set.empty, Map.empty, "")

    ("elm", "core", "Maybe", "Maybe") -> migrateSingleParamCollection
    ("elm", "core", "List", "List") ->   migrateSingleParamCollection
    ("elm", "core", "Array", "Array") -> migrateSingleParamCollection
    ("elm", "core", "Set", "Set") ->     migrateSingleParamCollection

    ("elm", "core", "Result", "Result") ->
      case tipeOldM of
        Just tipeOld ->
          case tipeOld of
            Can.TType _ _ paramsOld -> -- @WARNING MUST BE SAME TYPE?
              zipFull paramsOld params & (\p ->
                case p of
                  (Just p0o,Just p0):(Just p1o,Just p1):_ ->
                    let
                      (MigrationNested subt0 imps0 subft0 migrationName0) = (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMap "p0")
                      (MigrationNested subt1 imps1 subft1 migrationName1) = (canToMigration oldVersion newVersion scope interfaces recursionSet p1 (Just p1o) tvarMap "p1")

                      migration = case (p0o == p0, p1o == p1) of
                        (True, True) -> "" -- No migration necessary
                        (False, True) -> T.concat [ "Result.mapError ", subt0]
                        (True, False) -> T.concat [ "Result.map ", subt1 ]
                        (False, False) -> T.concat [ "Result.mapError ", subt0, " |> Result.map ", subt1 ]
                    in
                    xMigrationNested (migration, mergeImports imps0 imps1 & Set.insert moduleName, mergeMigrationDefinitions subft0 subft1, "")
                    -- DResult (canToMigration oldVersion newVersion scope interfaces recursionSet result tvarMap) (canToMigration oldVersion newVersion scope interfaces recursionSet err tvarMap)
                  _ ->
                    error "Fatal: impossible !2 param Result type! Please report this gen issue."
              )
            _ -> error "non-matching TType in Result gen"

        Nothing ->
          xMigrationNested ("Unimplemented -- This Result type has changed to something else", Set.empty, Map.empty, "")


    ("elm", "core", "Dict", "Dict") ->
      case tipeOldM of
        Just tipeOld ->
          case tipeOld of
            Can.TType _ _ paramsOld -> -- @WARNING MUST BE SAME TYPE?
              zipFull paramsOld params & (\p ->
                case p of
                  (Just p0o,Just p0):(Just p1o,Just p1):_ ->
                    let
                      (MigrationNested subt0 imps0 subft0 migrationName0) = (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMap "p0")
                      (MigrationNested subt1 imps1 subft1 migrationName1) = (canToMigration oldVersion newVersion scope interfaces recursionSet p1 (Just p1o) tvarMap "p1")

                      migration = case (p0o == p0, p1o == p1) of
                        (True, True) -> "" -- No migration necessary
                        (False, True) -> T.concat [ "Dict.toList |> List.map (Tuple.mapFirst ", subt0, ") |> Dict.fromList" ]
                        (True, False) -> T.concat [ "Dict.map (\\k v -> v |> ", subt1, ")" ]
                        (False, False) -> T.concat [ "Dict.toList |> List.map (Tuple.mapBoth ", subt0, " ", subt1, ") |> Dict.fromList" ]
                    in
                    xMigrationNested (migration, mergeImports imps0 imps1 & Set.insert moduleName, mergeMigrationDefinitions subft0 subft1, "")
                    -- DResult (canToMigration oldVersion newVersion scope interfaces recursionSet result tvarMap) (canToMigration oldVersion newVersion scope interfaces recursionSet err tvarMap)
                  _ ->
                    error "Fatal: impossible !2 param Result type! Please report this gen issue."
              )
            _ -> error "non-matching TType in Dict gen"
        Nothing ->
          xMigrationNested ("Unimplemented -- This Dict type has changed to something else", Set.empty, Map.empty, "")


    -- Values backed by JS Kernel types we cannot encode/decode
    ("elm", "virtual-dom", "VirtualDom", "Node")      -> kernelError
    ("elm", "virtual-dom", "VirtualDom", "Attribute") -> kernelError
    ("elm", "virtual-dom", "VirtualDom", "Handler")   -> kernelError
    ("elm", "core", "Process", "Id")                  -> kernelError
    ("elm", "core", "Platform", "ProcessId")          -> kernelError
    ("elm", "core", "Platform", "Program")            -> kernelError
    ("elm", "core", "Platform", "Router")             -> kernelError
    ("elm", "core", "Platform", "Task")               -> kernelError
    ("elm", "core", "Task", "Task")                   -> kernelError
    ("elm", "core", "Platform.Cmd", "Cmd")            -> kernelError
    ("elm", "core", "Platform.Sub", "Sub")            -> kernelError
    ("elm", "json", "Json.Decode", "Decoder")         -> kernelError
    ("elm", "json", "Json.Decode", "Value")           -> kernelError
    ("elm", "json", "Json.Encode", "Value")           -> kernelError
    ("elm", "http", "Http", "Body")                   -> kernelError
    ("elm", "http", "Http", "Part")                   -> kernelError
    ("elm", "http", "Http", "Expect")                 -> kernelError
    ("elm", "http", "Http", "Resolver")               -> kernelError
    ("elm", "parser", "Parser", "Parser")             -> kernelError
    ("elm", "parser", "Parser.Advanced", "Parser")    -> kernelError
    ("elm", "regex", "Regex", "Regex")                -> kernelError

    -- Not Kernel, but have functions... should we have them here?
    -- @TODO remove once we add test for functions in custom types
    ("elm", "url", "Url.Parser", "Parser") -> kernelError
    ("elm", "url", "Url.Parser.Internal", "QueryParser") -> kernelError

    -- Kernel concessions for Frontend Model and Msg
    -- ("elm", "file", "File", "File") -> ("File.File", Set.singleton moduleName, Map.empty)

    -- @TODO improve; These aliases will show up as VirtualDom errors which might confuse users
    -- ("elm", "svg", "Svg", "Svg") -> kernelError
    -- ("elm", "svg", "Svg", "Attribute") -> kernelError

    -- ((ModuleName.Canonical (Pkg.Name "elm" _) (N.Name n)), _) ->
    --   DError $ "❗️unhandled elm type: " <> (T.pack $ show moduleName) <> ":" <> (T.pack $ show name)
    --
    -- ((ModuleName.Canonical (Pkg.Name "elm-explorations" _) (N.Name n)), _) ->
    --   DError $ "❗️unhandled elm-explorations type: " <> (T.pack $ show moduleName) <> ":" <> (T.pack $ show name)

    (author, pkg, module_, typeName) ->
      -- Anything else must not be a core type, recurse to find it

      let handleUnion union =
            -- if isUserDefinedType_ tipe
            --     then
                  migrateUnion oldVersion newVersion scope identifier name interfaces newRecursionSet tvarMap union params
                    & (\(MigrationNested n imports subft migrationName) ->
                      xMigrationNested ( n
                      , if moduleName /= scope then
                          imports & Set.insert moduleName
                        else
                          imports
                      , subft
                          & addImports scope imports
                          & if moduleName /= scope then
                              addImport scope (moduleName) -- <> "(utop)")
                            else
                              id
                      , migrationName
                      )
                    )
                -- else
                --   -- Our top level type is not a user defined type, this can happen when libraries like
                --   -- MartinSStewart/elm-audio are used, resulting in `type alias FrontendMsg = Audio.Msg FrontendMsg_`
                --   xMigrationNested ( "old55NotAUserDefinedType" -- <> "<!5>"
                --       , if moduleName /= scope then
                --           Set.empty & Set.insert moduleName
                --         else
                --           Set.empty
                --       , Map.empty
                --           & addImports scope Set.empty
                --           & if moduleName /= scope then
                --               addImport scope (moduleName) -- <> "(utop)")
                --             else
                --               id
                --       , "old55NotAUserDefinedType"
                --       )

          handleAlias alias =
            aliasToFt oldVersion newVersion scope identifier name interfaces newRecursionSet alias oldValueRef
              & (\(MigrationNested n imports subft migrationName) ->
                xMigrationNested ( n -- <> "<!4>"
                , if moduleName /= scope then
                    imports & Set.insert moduleName
                  else
                    imports
                , subft
                    & addImports scope imports
                    & if moduleName /= scope then
                        addImport scope (moduleName) -- <> "(utop)")
                      else
                        id
                    --
                , migrationName
                )
              )
      in
      case findDef (moduleNameRaw) name interfaces of
        Just (Alias alias) -> handleAlias alias
        Just (Union union) -> handleUnion union
        Nothing ->
          MigrationNested
            ("XXXXXX subi fail: " <> nameToText moduleNameRaw <> " in " <> (T.pack . show $ (Map.keys interfaces)))
            Set.empty
            Map.empty
            ""


handleSeenRecursiveType :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
handleSeenRecursiveType oldVersion newVersion scope identifier@(author, pkg, newModule, _) interfaces recursionSet tipe@(Can.TType moduleName name params) tipeOldM tvarMap oldValueRef =
  -- error "tbc"
  let
      usageMigration :: [Migration]
      usageMigration =
        -- tvarResolvedParams
        params
          & fmap (\param -> canToMigration oldVersion newVersion scope interfaces recursionSet param tipeOldM tvarMap oldValueRef)

      usageParams :: Text
      usageParams =
        usageMigration
          & fmap migrationDef
          & T.intercalate " "

      usageImports :: Set.Set ModuleName.Canonical
      usageImports =
        usageMigration
          & fmap migrationImports
          & mergeAllImports
          -- & Set.insert oldModuleNameCanonical

      usageFts :: MigrationDefinitions
      usageFts =
        usageMigration
          & fmap migrationTopLevelDefs
          & mergeAllMigrationDefinitions

      typeScope :: Text
      typeScope =
        if moduleName == scope then
          ""
        else
          nameToText (canModuleName moduleName) <> "."

      typeName :: Text
      typeName =
        N.toText name

      migrationName :: Text
      migrationName = migrationNameUnderscored newModule oldVersion newVersion name

    in
    xMigrationNested ( if length params > 0 then
        "(" <> migrationName <> " " <> usageParams <> ")" -- <> "<!R>"
      else
        migrationName -- <> "<!R2>"
    , Set.insert moduleName usageImports
    , usageFts
    , migrationName
    )
