{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}

module Lamdera.Evergreen.MigrationGenerator where

import Data.Map (Map)
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.List as List
import qualified Data.Text as T
import qualified Data.Name as N
import NeatInterpolation

import qualified AST.Canonical as Can
import qualified Elm.ModuleName as ModuleName
import qualified Elm.Package as Pkg
import qualified Elm.Interface as Interface
import qualified Data.Utf8 as Utf8

import qualified Ext.Common
import Lamdera
import Lamdera.Types
import qualified Lamdera.Compile
import qualified Ext.ElmFormat
import qualified Ext.Query.Interfaces
import qualified Lamdera.Wire3.Helpers
import Lamdera.Wire3.Helpers (resolveTvars)
-- import StandaloneInstances

import Lamdera.Evergreen.MigrationGeneratorHelpers
import Lamdera.Evergreen.MigrationSpecialCases

betweenVersions :: CoreTypeDiffs -> Int -> Int -> String -> IO Text
betweenVersions coreTypeDiffs oldVersion newVersion root = do
    let
        paths = ["src/Evergreen/V" <> show oldVersion <> "/Types.elm", "src/Evergreen/V" <> show newVersion <> "/Types.elm"]
        moduleNameString = "Evergreen.V" <> show newVersion <> ".Types"

    Lamdera.Compile.makeDev root paths

    res <- Ext.Common.withProjectRoot root $ do
        interfaces <- Ext.Query.Interfaces.all paths
        case Map.lookup (N.fromChars moduleNameString) interfaces of
          Just interface ->
            generateFor coreTypeDiffs oldVersion newVersion interfaces (interfaces Map.! (N.fromChars $ "Evergreen.V" <> show newVersion <> ".Types"))

          Nothing ->
            error $ "Fatal: could not find the module `" <> moduleNameString <> "`, please report this issue in Discord with your project code."

    Ext.ElmFormat.formatOrPassthrough res

generateFor :: CoreTypeDiffs -> Int -> Int -> Interfaces -> Interface.Interface -> IO Text
generateFor coreTypeDiffs oldVersion newVersion interfaces iface_Types = do
  let
    moduleName :: ModuleName.Canonical
    moduleName = ModuleName.Canonical (Pkg.Name "author" "project") (N.fromChars $ "Evergreen.V" <> show newVersion <> ".Types")

    coreMigrations :: [(N.Name, Migration)]
    coreMigrations =
      coreTypeDiffs
        & fmap (\(t, oldHash, newHash) ->
            (t, coreTypeMigration (oldHash /= newHash) oldVersion newVersion interfaces moduleName t iface_Types)
        )
  pure $ migrationsToFile oldVersion newVersion coreMigrations moduleName


migrationsToFile :: Int -> Int -> [(N.Name, Migration)] -> ModuleName.Canonical -> Text
migrationsToFile oldVersion newVersion migrations moduleName =
  let
    imports :: Text
    imports = migrations
      & fmap snd
      & allImports
      -- a little weird but ensures current version of types, our entry point, is added to final migration imports...
      & Set.insert moduleName
      & importsToText
      & (++) additionalImports
      & List.sort
      & List.nub
      & T.intercalate "\n"

    additionalImports :: [Text]
    additionalImports = ["import Lamdera.Migrations exposing (..)"]

    coreMigrationDefs = migrations & fmap (migrationDef . snd)

    subMigrations = migrations & fmap (migrationTopLevelDefs . snd) & mergeAllSubDefs & allMigrations

    output =
      [ T.concat [ "module Evergreen.Migrate.V", show_ newVersion, " exposing (..)" ]
      , helpfulInformation
      , imports
      ] ++ coreMigrationDefs ++ [ subMigrations ]
  in
  output & T.intercalate "\n\n"


helpfulInformation :: Text
helpfulInformation =
  -- @TODO currently silly hack, but the 'Unimplemented' keyword is naively used to check if there are
  -- any pending migrations... but that means we can't use that word in comments, so we use the utf8 substitute
  -- character trick in the `Unimplementеd` text below which won't match on the basic string search.
  -- In future the better resolution would be to detect the Unimplemented keyword in the AST, so the user
  -- can just comment stuff out but leave it for record.
  [text|
    {-| This migration file was automatically generated by the lamdera compiler.

    It includes:

      - A migration for each of the 6 Lamdera core types that has changed
      - A function named `migrate_ModuleName_TypeName` for each changed/custom type

    Expect to see:

      - `Unimplementеd` values as placeholders wherever I was unable to figure out a clear migration path for you
      - `@NOTICE` comments for things you should know about, i.e. new custom type constructors that won't get any
        value mappings from the old type by default

    You can edit this file however you wish! It won't be generated again.

    See <https://dashboard.lamdera.com/docs/evergreen> for more info.
    -}
  |]


coreTypeMigration :: Bool -> Int -> Int -> Interfaces -> ModuleName.Canonical -> N.Name -> Interface.Interface -> Migration
coreTypeMigration typeDidChange oldVersion newVersion interfaces newModule typeName interface = do
  let
    recursionIdentifier :: (ModuleName.Canonical, N.Name)
    recursionIdentifier = (newModule, typeName)

    recursionSet :: RecursionSet
    recursionSet = Set.singleton recursionIdentifier

    identifier :: TypeIdentifier
    identifier = asIdentifier_ recursionIdentifier

    t :: Text
    t = nameToText typeName

    newModuleName :: Text
    newModuleName = newModule & dropCan & N.toText

    oldModule :: ModuleName.Canonical
    oldModule = asOldModule (dropCan newModule) newVersion oldVersion

    oldModuleName :: Text
    oldModuleName = oldModule & dropCan & N.toText

    migrationWrapper :: Text -> Text
    migrationWrapper migration = do
      T.concat
        ["\n", lowerFirstLetter_ t, " : ", oldModuleName, ".", t, " -> ", migrationTypeForType typeName , " ", newModuleName, ".", t, " ", newModuleName, ".", msgForType typeName, "\n"
        , lowerFirstLetter_ $ nameToText typeName, " old = ", migration
        ]

  if typeDidChange
    then
      case (findDef oldModule typeName interfaces, findDef newModule typeName interfaces) of
        (Just (Alias mOld typeNameOld aliasOld), Just (Alias mNew typeNameNew aliasNew)) -> do
          let
            diffableAlias = migrateAlias oldVersion newVersion mOld newModule identifier typeNameOld typeNameNew interfaces recursionSet aliasOld aliasNew "old" [] []
            (MigrationNested migrationImpl imps subDefs) = diffableAlias
            migration = T.concat ["\n    ", migrationWrapperForType typeName, " ( ", migrationImpl, " old, Cmd.none )"]
          (MigrationNested (migrationWrapper migration) imps subDefs)

        (Just typeDefOld@(Union mOld typeNameOld unionOld), Just (Union mNew typeNameNew unionNew)) -> do
          let
            diffableUnion = migrateUnion typeDefOld oldVersion newVersion newModule identifier typeName interfaces recursionSet [] [] unionNew

            (MigrationNested migrationImpl imps subDefs) = diffableUnion
            migration = T.concat ["\n    ", migrationWrapperForType typeName, " ( ", migrationImpl, " old, Cmd.none )"]
          (MigrationNested (migrationWrapper migration) imps subDefs)

        (Nothing, _) ->
          error $ concat [ "Tried to generate a migration for core type ", N.toChars typeName, ", but I couldn't find it defined in src/Evergree/V", show oldVersion, "/Types.elm" ]

        (_, Nothing) ->
          error $ concat [ "Tried to generate a migration for core type ", N.toChars typeName, ", but I couldn't find it defined in src/Evergree/V", show newVersion, "/Types.elm" ]
    else
      (MigrationNested (migrationWrapper (unchangedForType typeName)) Set.empty Map.empty)


-- migrateTypeDef :: TypeDef
migrateTypeDef typeOld typeNew oldVersion newVersion interfaces tvarMapOld tvarMapNew =
  case (typeOld, typeNew) of
    (Alias mOld typeNameOld aliasOld, Alias mNew typeNameNew aliasNew) ->
      let
        recursionIdentifier :: (ModuleName.Canonical, N.Name)
        recursionIdentifier = (mNew, typeNameNew)

        recursionSet :: RecursionSet
        recursionSet = Set.singleton recursionIdentifier

        identifier :: TypeIdentifier
        identifier = asIdentifier_ recursionIdentifier
      in
      migrateAlias oldVersion newVersion mOld mNew identifier typeNameOld typeNameNew interfaces recursionSet aliasOld aliasNew "old" tvarMapOld tvarMapNew

    (typeDefOld@(Union mOld typeNameOld unionOld), Union mNew typeNameNew unionNew) ->
      let
        recursionIdentifier :: (ModuleName.Canonical, N.Name)
        recursionIdentifier = (mNew, typeNameNew)

        recursionSet :: RecursionSet
        recursionSet = Set.singleton recursionIdentifier

        identifier :: TypeIdentifier
        identifier = asIdentifier_ recursionIdentifier
      in
      -- @TODO use unionOld
      -- @TODO pass params

      migrateUnion typeDefOld oldVersion newVersion mNew identifier typeNameNew interfaces recursionSet tvarMapOld tvarMapNew unionNew

    -- @ADVANCED handle case where user is aliasing a custom type?

    (Union mOld typeNameOld unionOld, Alias mNew typeNameNew aliasNew) ->
      unimplemented "" ("`" <> N.toText typeNameNew <> "` was a custom type, but now it's a type alias. I need you to write this migration.")

    (Alias mOld typeNameOld aliasOld, Union mNew typeNameNew unionNew) ->
      unimplemented "" ("`" <> N.toText typeNameOld <> "` was a type alias, but now it's a custom type. I need you to write this migration.")


-- A top level Custom Type definition i.e. `type Herp = Derp ...`
migrateUnion :: TypeDef -> Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> TvarMap -> TvarMap -> Can.Union -> Migration
migrateUnion typeDefOld oldVersion newVersion scope identifier@(author, pkg, newModule, tipe) typeNameNew interfaces recursionSet tvarMapOld tvarMapNew newUnion =
  case typeDefOld of
    (Alias moduleNameOld typeNameOld aliasOld) ->
      unimplemented "" ("`" <> N.toText typeNameNew <> "` was a type alias, but now it's a custom type. I need you to write this migration.")
    (Union moduleNameOld typeNameOld unionOld) ->
      migrateUnion_ author pkg unionOld newUnion tvarMapOld tvarMapNew oldVersion newVersion typeNameNew newModule identifier (dropCan moduleNameOld) interfaces recursionSet scope


migrateUnion_ :: Pkg.Author -> Pkg.Project -> Can.Union -> Can.Union -> TvarMap -> TvarMap -> Int -> Int -> N.Name -> N.Name -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> ModuleName.Canonical -> Migration
migrateUnion_ author pkg oldUnion newUnion tvarMapOld tvarMapNew oldVersion newVersion typeName newModule identifier oldModuleName interfaces recursionSet scope =
  let
    oldModuleNameCanonical :: ModuleName.Canonical
    oldModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) oldModuleName

    newModuleNameCanonical :: ModuleName.Canonical
    newModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) newModule

    tvarsNew :: [N.Name]
    tvarsNew = Can._u_vars newUnion

    tvarsOld :: [N.Name]
    tvarsOld = Can._u_vars oldUnion

    tvarPairs :: [(Can.Type, Can.Type)]
    tvarPairs =
      zip (loadTvars tvarsOld tvarMapOld) (loadTvars tvarsNew tvarMapNew)

    tvarMigrations :: [Migration]
    tvarMigrations =
      tvarPairs
        & imap (\i (paramOld, paramNew) ->
          let
            ft@(MigrationNested migration imps subDefs) =
              canToMigration oldVersion newVersion scope interfaces recursionSet paramNew (Just paramOld) tvarMapOld ("p" <> show_ i)
          in
          if migration == "" then
            -- Because paramaterised migrations are passed into functions that expect `v1 -> v2` functions, we
            -- need to pass in a function even if there is no migration necessary, i.e. `String -> String`.
            ft { migrationDef = "identity" }
          else
            ft
        )

    tvarMigrationTextsCombined :: Text
    tvarMigrationTextsCombined =
      tvarMigrations
        & fmap migrationDef
        & parenthesize
        & T.intercalate " "

    localScope :: ModuleName.Canonical
    localScope =
      ModuleName.Canonical (Pkg.Name author pkg) newModule

    oldConstructorsMigrations :: [Migration]
    oldConstructorsMigrations =
      Can._u_alts oldUnion
        & fmap (\(Can.Ctor oldConstructor index int oldParams) ->
          -- For each OLD constructor type param
          genOldConstructorMigration oldModuleName moduleScope typeName interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion newUnion oldUnion oldConstructor oldParams
        )


    -- @TODO is this needed anymore?
    imports :: ElmImports
    imports = oldConstructorsMigrations & allImports

    oldConstructorsMigrationDefinitions :: MigrationDefinitions
    oldConstructorsMigrationDefinitions = oldConstructorsMigrations & allSubDefs

    moduleScope :: Text
    moduleScope = nameToText newModule <> "."

    moduleScopeOld :: Text
    moduleScopeOld = nameToText oldModuleName <> "."

    migrationName :: Text
    migrationName = migrationNameUnderscored newModule oldVersion newVersion typeName

    migration :: Text
    migration = migrationName <> " " <> tvarMigrationTextsCombined -- <> "<!2>"

    paramMigrationPairs = zip tvarsOld tvarsNew

    paramMigrationFnsTypeSig :: [Text]
    paramMigrationFnsTypeSig =
      paramMigrationPairs
        & fmap (\(oldT, newT) -> T.concat [ "(", N.toText oldT, "_old -> ", N.toText newT, "_new)" ] )

    paramMigrationVars :: Text
    paramMigrationVars =
      paramMigrationPairs
        & fmap (\(oldT, newT) -> T.concat [ "migrate_", N.toText oldT ] )
        & T.intercalate " "

    migrationTypeSignature :: Text
    migrationTypeSignature = T.concat
      [ paramMigrationFnsTypeSig & T.intercalate " -> " & suffixIfNonempty " -> "
      , " "
      , oldModuleName & N.toText, ".", typeName & N.toText
      , " "
      , tvarsOld & fmap (\tvar -> T.concat [N.toText tvar, "_old"]) & T.intercalate " "
      , " -> "
      , newModule & N.toText, ".", typeName & N.toText
      , " "
      , tvarsNew & fmap (\tvar -> T.concat [N.toText tvar, "_new"]) & T.intercalate " "
      ]

    constructorCaseMigrations :: Text
    constructorCaseMigrations =
      oldConstructorsMigrations
        & fmap migrationDef
        & flip (++) (newConstructorWarnings typeName moduleScopeOld newUnion oldUnion newVersion)
        & T.concat

    newConstructorWarnings :: N.Name -> Text -> Can.Union -> Can.Union -> Int -> [Text]
    newConstructorWarnings typeName moduleScope newUnion oldUnion newVersion =
      Can._u_alts newUnion
        & filterMap (\(Can.Ctor newConstructorName index int newParams) -> do
          case Can._u_alts oldUnion & List.find (\(Can.Ctor oldConstructorName _ _ _) ->
                 newConstructorName == oldConstructorName
            ) of
            Nothing ->
              let params =
                    if length newParams > 0
                      then " " <> (T.intercalate " " (fmap asTypeName newParams))
                      else ""
              in
              -- This constructor is missing a match in the old type, warn the user this new constructor exists
              Just $ T.concat [
                "        {- @NOTICE `", N.toText newConstructorName, params, "` was added in V", show_ newVersion, ".\n",
                "        This is just a reminder in case migrating some subset of the old data to this new value was important.\n",
                "        See https://lamdera.com/tips/modified-custom-type for more info.\n",
                "        -}\n"
                ]
            Just _ ->
              -- This constructor has a match in the old type, so skip it
              Nothing
        )
        & (\notices ->
              if length notices > 0 then
                [ "    notices ->\n" <>
                  "        " <> T.concat notices <> "\n" <>
                  "        Unimplemented"
                ]
              else
                []
          )
  in
  debugHaskellPass "migrateUnion_inputs" (identifier, tvarsOld, tvarsNew, tvarMapOld, tvarMapNew, oldUnion, newUnion) $
  debugMigrationIncludes_ "migrateUnion_" $
  case specialCaseMigration identifier of
    Just migrationDef ->
      MigrationNested
        migration
        (Set.fromList [oldModuleNameCanonical, newModuleNameCanonical] <> imports)
        (Map.singleton (newModuleNameCanonical, typeName) migrationDef
            & debugHaskellWhen (debugMigrationFn == migration) "debugMigrationFn:migrateUnion_:specialCased"
            & Map.union (allSubDefs tvarMigrations)
            -- & Map.union oldConstructorsMigrationDefinitions
        )

    Nothing ->
      xMigrationNested
      ( migration
      , Set.empty
      , (MigrationDefinition
            { imports = Set.fromList [oldModuleNameCanonical, newModuleNameCanonical] <> imports
            , migrations =
              -- Map.singleton migrationName $
              T.concat
                [ migrationName, " : ", migrationTypeSignature, "\n"
                , [ migrationName, paramMigrationVars, " old =\n" ] & T.intercalate " "
                , "  case old of\n"
                , constructorCaseMigrations
                ]
            }
            & debugHaskellWhen (debugMigrationFn == migrationName) "debugMigrationFn:migrateUnion_"
            & Map.singleton (newModuleNameCanonical, typeName)
          )
          & Map.union (allSubDefs tvarMigrations)
          & Map.union oldConstructorsMigrationDefinitions
      )


genOldConstructorMigration :: N.Name -> Text -> N.Name -> Interfaces -> TvarMap -> TvarMap -> RecursionSet -> ModuleName.Canonical -> Int -> Int -> Can.Union -> Can.Union -> N.Name -> [Can.Type] -> Migration
genOldConstructorMigration oldModuleName moduleScope typeName interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion newUnion oldUnion oldConstructorName oldParams =
  let
    newCtorM :: Maybe Can.Ctor
    newCtorM = Can._u_alts newUnion & List.find (\(Can.Ctor newConstructorName _ _ _) ->
      newConstructorName == oldConstructorName
      || (newConstructorName == (oldConstructorName & N.toText & (\v -> v <> "_") & N.fromText))
      )

    migration_ :: Migration
    migration_ =
      case newCtorM of
      Just (Can.Ctor newConstructorName _ _ newParams) ->
        let
            paramMigrations :: [Migration]
            paramMigrations =
              zipFull oldParams newParams
                & imap (\i (paramOldM, paramNewM) ->
                  migrateParam i paramOldM paramNewM interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion
                )

            fullMigration =
              xMigrationNested ( if List.length oldParams > 0 then
                  let migration =
                        paramMigrations
                          & fmap migrationDef
                          & (\paramMigrations -> T.concat [ moduleScope, N.toText newConstructorName, " ", (paramMigrations & T.intercalate " ") ])
                  in
                  T.concat
                      [ "    ", N.toText oldModuleName, ".", N.toText oldConstructorName, " ", (imap (\i _ -> "p" <> show_ i) oldParams & T.intercalate " ")
                      , " -> \n"
                      , migration & T.lines & fmap (\v -> T.concat ["        ", v ]) & T.unlines
                      , "\n"
                      ]
                else
                  T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructorName, " -> ", moduleScope, N.toText newConstructorName, "\n"]
              , paramMigrations
                  & fmap migrationImports
                  & mergeAllImports
              , paramMigrations
                  & fmap migrationTopLevelDefs
                  & mergeAllSubDefs
              )
        in
        fullMigration

      Nothing ->
        let
          oldConstructorRemovedMessage :: Text
          oldConstructorRemovedMessage =
            T.concat [
              " ->\n",
              "           {- `", N.toText oldConstructorName, "` was removed or renamed in V", show_ newVersion, " so I couldn't figure out how to migrate it.\n",
              "           I need you to decide what happens to this ", N.toText oldModuleName, ".", N.toText oldConstructorName, " value in a migration.\n",
              "           See https://lamdera.com/tips/modified-custom-type for more info.\n",
              "           -}\n",
              "           Unimplemented\n"
            ]
        in
        xMigrationNested ( -- No old constructor with same name, so this is a new/renamed constructor
          if List.length oldParams > 0
            then
              T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructorName, " ", (imap (\i _ -> "p" <> show_ i) oldParams & T.intercalate " "), oldConstructorRemovedMessage]
            else
              T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructorName, oldConstructorRemovedMessage]
        , Set.empty
        , Map.empty
        )
  in
  migration_


migrateParam :: Int -> Maybe Can.Type -> Maybe Can.Type -> Interfaces -> TvarMap -> TvarMap -> RecursionSet -> ModuleName.Canonical -> Int -> Int -> Migration
migrateParam i paramOldM paramNewM interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion =
  -- debugHaskell "migrateParam" $
  case (paramOldM, paramNewM) of
    (Just paramOld, Just paramNew) ->
      let ft@(MigrationNested migration imps subDefs) =
            canToMigration oldVersion newVersion localScope interfaces recursionSet paramNew (Just paramOld) tvarMapOld ("p" <> show_ i)

          appliedMigration =
            if isTvar paramOld then
              case paramOld of
                Can.TVar name ->
                  xMigrationNested (T.concat ["( migrate_", N.toText name, " p", show_ i, ")"], imps, subDefs)
                _ ->
                  error "impossible:appliedMigration tvar /= tvar"
            else if isEquivalentElmType "External.Paramed" (tvarResolveParam tvarMapOld paramOld) (tvarResolveParam tvarMapNew paramNew) then
              -- debugHaskellPass "thethingis" (
              --     (tvarResolveParam tvarMapOld paramOld)
              --   , (tvarResolveParam tvarMapNew paramNew)
              --   ) $
              xMigrationNested (T.concat ["p", show_ i], Set.empty, Map.empty)
            else if isAnonymousRecord paramOld then
              ft
            else if isUserDefinedType_ paramOld then
              xMigrationNested (T.concat ["(p", show_ i, " |> ", migration, ")"], imps, subDefs)
            else
              xMigrationNested (T.concat ["(p", show_ i, " |> ", migration, ")"], imps, subDefs)
      in
      appliedMigration

    (Just paramOld, Nothing) ->
      unimplemented "migrateParam:noNew" ("Warning: old variant didn't get mapped to anything, check this is what you want")

    (Nothing, Just paramNew) ->
      unimplemented "migrateParam:noOld" ("This new variant needs to be initialised")

    _ -> error "impossible, zip produced a value without any contents"


-- A top level Alias definition i.e. `type alias ...`
migrateAlias :: Int -> Int -> ModuleName.Canonical -> ModuleName.Canonical -> TypeIdentifier -> TypeName -> TypeName -> Interfaces -> RecursionSet -> Can.Alias -> Can.Alias -> Text -> TvarMap -> TvarMap -> Migration
migrateAlias oldVersion newVersion moduleOld scope identifier@(author, pkg, newModule, typeNameNew) typeNameOld typeName interfaces recursionSet aliasOld@(Can.Alias tvarsOld typeOld) aliasNew@(Can.Alias tvarsNew typeNew) oldValueRef tvarMapOld tvarMapNew =
  let
    -- @TODO tvar map construction needed here?
    (MigrationNested migration imps subDefs) = canToMigration oldVersion newVersion scope interfaces recursionSet typeNew (Just typeOld) [] oldValueRef

    oldModuleNameCanonical :: ModuleName.Canonical
    oldModuleNameCanonical = moduleOld

    newModuleNameCanonical :: ModuleName.Canonical
    newModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) newModule

    tvarPairs :: [(Can.Type, Can.Type)]
    tvarPairs =
      zip (loadTvars tvarsOld tvarMapOld) (loadTvars tvarsOld tvarMapOld)

    tvarMigrations :: [Migration]
    tvarMigrations =
      tvarPairs
        & imap (\i (tvarOld, tvarNew) ->
          let
            ft@(MigrationNested migration imps subDefs) =
              canToMigration oldVersion newVersion scope interfaces recursionSet tvarNew (Just tvarOld) tvarMapOld ("p" <> show_ i)
          in
          if migration == "" then
            -- Because paramaterised migrations are passed into functions that expect `v1 -> v2` functions, we
            -- need to pass in a function even if there is no migration necessary, i.e. `String -> String`.
            ft { migrationDef = "identity" }
          else
            ft
        )

    tvarMigrationTextsCombined :: Text
    tvarMigrationTextsCombined =
      tvarMigrations
        & fmap migrationDef
        & parenthesize
        & T.intercalate " "

    moduleName = (ModuleName.Canonical (Pkg.Name author pkg) newModule)

    newModuleName = newModule & N.toText
    oldModuleName = moduleOld & dropCan & N.toText

    migrationName_ :: Text
    migrationName_ = migrationNameUnderscored newModule oldVersion newVersion typeName

    migration_ :: Text
    migration_ = migrationName_ <> " " <> tvarMigrationTextsCombined -- <> "<!2>"

    -- @TODO this doesn't feel right here?
    applyOldValueIfNotRecord =
      if isRecord typeNew then
        ""
      else
        T.concat [oldValueRef, " |> "]

    -- !x = debugHaskell "applyOldValueIfNotRecord" (isRecord tipe, tipe)

  in
  debugHaskellPass "migrateAlias_inputs" (identifier, aliasOld, aliasNew, tvarMapOld, tvarMapNew) $
  debugMigrationIncludes_ "migrateAlias" $
  case specialCaseMigration identifier of
    Just migrationDef ->
      MigrationNested
        -- migrationName_ the problem is here – needs to be migratin same as union so it takes tvar migrations into account
        migration_
        (Set.fromList [oldModuleNameCanonical, newModuleNameCanonical] <> imps)
        (migrationDef
          & debugHaskellWhen (debugMigrationFn == migrationName_) "debugMigrationFn:migrateAlias_:specialCased"
          & Map.singleton (newModuleNameCanonical, typeNameNew)
          -- & Map.union subDefs
        )
    Nothing ->
      xMigrationNested
      ( migration_
      , Set.fromList [oldModuleNameCanonical, newModuleNameCanonical]
      , (MigrationDefinition
            { imports = imps
            , migrations =
                T.concat
                  ["\n", migrationName_, " : ", oldModuleName, ".", nameToText typeNameOld, " -> ", newModuleName, ".", nameToText typeName, "\n"
                  , migrationName_, " ", oldValueRef, " = ", applyOldValueIfNotRecord, migration
                  ]
            }
            & debugHaskellWhen (debugMigrationFn == migrationName_) "debugMigrationFn:migrateAlias_"
            & Map.singleton (newModuleNameCanonical, typeNameNew)
          )
          & Map.union subDefs
      )


canToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> TvarMap -> Text -> Migration
canToMigration oldVersion newVersion scope interfaces recursionSet typeNew typeOldM tvarMapNew oldValueRef =
  -- debugMigrationIncludes_ "canToMigration" $
  -- let !x = debugHaskell "canToMigration" (typeOldM, tipe)
  -- in
  let
    tvarMapOld = []
    skip =
      case typeOldM of
        Just typeOld ->
          if isEquivalentElmType "cantomigration" (resolveTvars tvarMapOld typeOld) (resolveTvars tvarMapNew typeNew)
            then True
            else False
        _ -> False
  in
  if skip
    then
      xMigrationNested (oldValueRef, Set.empty, Map.empty)
    else
      canToMigration_ oldVersion newVersion scope interfaces recursionSet typeNew typeOldM tvarMapNew oldValueRef

canToMigration_ :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> TvarMap -> Text -> Migration
canToMigration_ oldVersion newVersion scope interfaces recursionSet tipe typeOldM tvarMapNew oldValueRef =
  case tipe of
    Can.TType moduleName name params ->
      typeToMigration oldVersion newVersion scope interfaces recursionSet tipe typeOldM tvarMapNew oldValueRef

      -- if containsUserTypes tvarMap tipe
      --   then typeToMigration oldVersion newVersion scope interfaces recursionSet tipe typeOldM tvarMap oldValueRef
      --   else xMigrationNested ("", Set.empty, Map.empty)

    Can.TAlias moduleName name tvarMap_ aliasType ->
      canAliasToMigration oldVersion newVersion scope interfaces recursionSet tipe typeOldM tvarMapNew oldValueRef

    Can.TRecord newFields isPartial ->
      recordToMigration oldVersion newVersion scope interfaces recursionSet tipe typeOldM tvarMapNew oldValueRef

    Can.TTuple t1 t2 mt3 ->
      let
        (MigrationNested subt imps subDefs) =
          canToMigration oldVersion newVersion scope interfaces recursionSet t1 typeOldM tvarMapNew oldValueRef
        (MigrationNested subt2 imps2 subDefs2) =
          canToMigration oldVersion newVersion scope interfaces recursionSet t2 typeOldM tvarMapNew oldValueRef
      in
      case mt3 of
        Just t3 ->
          let
            (MigrationNested subt3 imps3 subDefs3) =
              canToMigration oldVersion newVersion scope interfaces recursionSet t3 typeOldM tvarMapNew oldValueRef
          in
          -- @TODO this is the wrong migration, need a mapAll for all 3 tuple values
          xMigrationNested (T.concat ["(", subt, ", ", subt2, ", ", subt3, ")"], mergeAllImports [imps,imps2,imps3], mergeAllSubDefs [subDefs,subDefs2,subDefs3])

        Nothing ->
          xMigrationNested (T.concat ["Tuple.mapBoth (", subt, ", ", subt2, ")"], imps <> imps2, Map.union subDefs subDefs2)

    Can.TUnit ->
      xMigrationNested ("()", Set.empty, Map.empty)

    Can.TVar name ->
      xMigrationNested ("migrate_" <> N.toText name, Set.empty, Map.empty)

    Can.TLambda _ _ ->
      error "Fatal: impossible function type! Please report this gen issue."


canAliasToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> TvarMap -> Text -> Migration
canAliasToMigration oldVersion newVersion scope interfaces recursionSet typeNew@(Can.TAlias moduleNameNew typeNameNew tvarMapNew aliasTypeNew) typeOldM tvarMap oldValueRef =
  let
    module_ =
      case moduleNameNew of
        (ModuleName.Canonical (Pkg.Name author pkg) module_) -> module_

    newModule = module_

    identifier = asIdentifier_ (moduleNameNew, typeNameNew)

    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    oldModule :: ModuleName.Canonical
    oldModule = asOldModule newModule newVersion oldVersion
  in
  debugMigrationIncludes_ "canAliasToMigration" $
  case aliasTypeNew of
    Can.Holey cType ->
      case typeOldM of
        Just (typeOld@(Can.TAlias moduleNameOld typeNameOld tvarMapOld aliasType)) ->
          let
            usageParamSubDefs :: [Migration]
            usageParamSubDefs =
              zip tvarMapOld tvarMapNew
                & fmap (\((nOld, paramTypeOld), (nNew, paramTypeNew)) ->
                  canToMigration oldVersion newVersion scope interfaces recursionSet paramTypeNew (Just paramTypeOld) tvarMapNew oldValueRef
                )

            usageParamNames :: Text
            usageParamNames =
              usageParamSubDefs
                & fmap migrationDef
                & T.intercalate " "

            tvarsNew :: [Text]
            tvarsNew = tvarMapNew & fmap (N.toText . fst)

            tvarsOld :: [Text]
            tvarsOld = tvarMapOld & fmap (N.toText . fst)

            (MigrationNested subt imps subDefs) :: Migration =
              let
                paramPairs = zipWith (\(n1,t1) (n2,t2) -> (n1, t1, t2)) tvarMapOld tvarMapNew
                res = canToMigration oldVersion newVersion moduleNameNew interfaces recursionSet cType (Just typeOld) tvarMapOld oldValueRef
              in
              res

            typeScope =
              if moduleNameNew == scope then
                ""
              -- else if isUserType identifier then
              --   nameToText module_ <> "."
              else
                T.concat [nameToText module_, "."]

            debugIden = "" -- <> "<ah>"

            migrationName :: Text
            migrationName = migrationNameUnderscored newModule oldVersion newVersion typeNameNew

            paramMigrationPairs = zip tvarsOld tvarsNew

            paramMigrationFnsTypeSig :: [Text]
            paramMigrationFnsTypeSig =
              paramMigrationPairs
                & fmap (\(oldT, newT) -> T.concat [ "(", oldT, "_old -> ", newT, "_new)" ] )

            paramMigrationVars :: Text
            paramMigrationVars =
              paramMigrationPairs
                & fmap (\(oldT, newT) -> T.concat [ "migrate_", oldT ] )
                & T.intercalate " "

            oldType = T.concat [oldModuleName & N.toText, ".", typeNameNew & N.toText]
            newType = T.concat [newModule & N.toText, ".", typeNameNew & N.toText]

            migrationTypeSignature :: Text
            migrationTypeSignature = T.concat
              [ paramMigrationFnsTypeSig & T.intercalate " -> " & suffixIfNonempty " -> "
              , " "
              , oldType
              , " "
              , tvarsOld & fmap (\tvar -> T.concat [tvar, "_old"]) & T.intercalate " "
              , " -> "
              , newType
              , " "
              , tvarsNew & fmap (\tvar -> T.concat [tvar, "_new"]) & T.intercalate " "
              ]

            applyOldValueIfNotRecord =
              if isRecord cType then
                ""
              else
                T.concat [oldValueRef, " |> "]

            typeDef =
              if isUserDefinedType_ cType then
                T.concat
                  [ migrationName, " : ", migrationTypeSignature, "\n"
                  , migrationName, " ", paramMigrationVars, " ", oldValueRef, " = ", applyOldValueIfNotRecord, subt
                  ]

              else
                -- "-- oopsie\n"
                T.concat [ "-- no migration for primitive: ", migrationName, "\n" ]

            migration =
              if length tvarMapNew > 0 then
                T.concat ["(", migrationName, " ", usageParamNames, ")"] -- <> "<!2>"
              else
                migrationName -- <> "<!3>"
          in
            xMigrationNested ( migration , Set.empty,
              (Map.singleton (moduleNameNew, typeNameNew) $
                MigrationDefinition
                  { imports = Set.fromList [moduleNameNew, moduleNameOld]
                  , migrations = typeDef
                  }
              )
                & Map.union subDefs
                & Map.union (mergeAllSubDefs (fmap migrationTopLevelDefs usageParamSubDefs))
             )

        Just typeOld ->
          -- The old type is not an alias, but the new type is. Is this the right treatment?
          unimplemented ""
            ("`" <> N.toText typeNameNew <> "` was a concrete type, but now it's a type alias. I need you to write this migration." )

        Nothing ->
          unimplemented "canAliasToMigration" (T.concat ["I couldn't find an old type named `", N.toText oldModuleName, ".", N.toText typeNameNew, "`. I need you to write this migration.\n" ])

    Can.Filled cType ->
      -- @TODO hypothesis...
      -- If an alias is filled, then it can't have any open holes within it either?
      -- So we can take this opportunity to reset tvars to reduce likeliness of naming conflicts?
      let
        (MigrationNested subt imps subDefs) = canToMigration oldVersion newVersion moduleNameNew interfaces recursionSet cType typeOldM [] oldValueRef
        debugIden = "" -- <> "<af>"
      in
      xMigrationNested (
        debugIden <> "🔴" <>
        if module_ == (dropCan scope) then
          N.toText typeNameNew
        else if isUserType identifier then
          T.concat [nameToText module_, "."]
        else
          T.concat [nameToText module_, ".", N.toText typeNameNew]
      , imps
      , subDefs
      )


recordToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> TvarMap -> Text -> Migration
recordToMigration oldVersion newVersion scope interfaces recursionSet tipe@(Can.TRecord newFields isPartial) typeOldM tvarMap oldValueRef =
  debugMigrationIncludes_ "recordToMigration" $
  case isPartial of
    Just whatIsThis ->
      xMigrationNested ("ERROR TRecord, please report this!", Set.empty, Map.empty)
      -- DError "must not contain partial records"

    Nothing ->
      let
        fieldMapOld :: Map N.Name Can.FieldType
        fieldMapOld =
          case typeOldM of
            Just typeOld ->
              case Lamdera.Wire3.Helpers.resolveFieldMap typeOld tvarMap of
                Just fields -> fields
                Nothing -> Map.empty
            _ -> Map.empty

        fieldMigrations :: [(Text, Migration)]
        fieldMigrations =
          newFields
            & Map.toList
            -- Restore user's field code-ordering to keep types looking familiar
            & List.sortOn (\(name, (Can.FieldType index ftipe)) -> index)
            & fmap (\(name, (Can.FieldType index ftipe)) ->
                case Map.lookup name fieldMapOld of
                  Just (Can.FieldType index_ ftypeOld) ->
                    if isEquivalentElmType name ftypeOld ftipe then
                      (N.toText name
                      , xMigrationNested
                        ( T.concat[ oldValueRef, ".", N.toText name]
                        , Set.empty
                        , Map.empty
                        )
                      )
                    else
                      -- debugHaskellPassDiffWhen (name == "unchangedAllTypes") "these types are unequal" (ftypeOld, ftipe) $
                      if isAnonymousRecord ftipe
                        then
                          -- In order to deal with anonymous records inline, we have to change
                          -- the name of the value to avoid shadowing the `old.` ref.
                          let
                            readMaybeInt :: Text -> Maybe Int
                            readMaybeInt = readMaybeText

                            -- For every additional anonymous nesting, bump the reference number
                            recname :: Text
                            recname =
                              case oldValueRef of
                                "old" -> "rec"
                                _ ->
                                  oldValueRef
                                    & T.replace "rec" ""
                                    & readMaybeInt
                                    & withDefault (0 :: Int)
                                    & (+) 1
                                    & show_
                                    & (<>) "rec"

                            (MigrationNested st imps subDefs) = recordToMigration oldVersion newVersion scope interfaces recursionSet ftipe (Just ftypeOld) tvarMap recname
                          in
                          ( N.toText name
                          , xMigrationNested
                            ( T.concat [oldValueRef, ".", N.toText name, " |> (\\", recname, " -> ", st, ")"], imps, subDefs)
                          )
                        else
                          let
                            (MigrationNested st imps subDefs) =
                              canToMigration oldVersion newVersion scope interfaces recursionSet ftipe (Just (ftypeOld)) tvarMap oldValueRef
                          in
                          ( N.toText name
                          , xMigrationNested ( T.concat [oldValueRef, ".", N.toText name, " |> ", st ], imps, subDefs)
                          )

                  Nothing ->
                    -- This field did not exist in the old version. We need an init!
                    let (MigrationNested st imps ft) = canToMigration oldVersion newVersion scope interfaces recursionSet ftipe Nothing tvarMap oldValueRef
                    in
                    ( N.toText name, xMigrationNested (T.concat["Unimplemented -- Type `", qualifiedTypeName ftipe, "` was added in V", show_ newVersion, ". I need you to set a default value."], imps, ft) )
            )
            & (\v -> v ++ missingFields)

        missingFields :: [(Text, Migration)]
        missingFields =
          fieldMapOld
            & Map.toList
            & filterMap (\(name, (Can.FieldType index tipe)) ->
              case Map.lookup name newFields of
                Just (Can.FieldType index_ typeOld) ->
                  Nothing
                Nothing ->
                  Just ( N.toText name
                       , unimplemented ("recordToMigration:" <> qualifiedTypeName tipe)
                          ( T.concat["Field of type `", qualifiedTypeName tipe, "` was removed in V", show_ newVersion
                          , ". I need you to do something with the `", oldValueRef, ".", N.toText name, "` value if you wish to keep the data, then remove this line."]
                          )
                  )
            )

        fieldsFormatted :: Text
        fieldsFormatted =
          fieldMigrations
            & fmap (\(fieldname, (MigrationNested st imps ft)) -> fieldname <> " = " <> st)
            & T.intercalate "\n    , "

        imports :: ElmImports
        imports =
          fieldMigrations
            & foldl (\acc (name, (MigrationNested st imps ft)) -> acc <> imps) Set.empty

        mergedSubDefs :: MigrationDefinitions
        mergedSubDefs = fieldMigrations & fmap snd & allSubDefs

      in
      xMigrationNested
        ( "\n    { " <> fieldsFormatted <> "\n    }"
        , imports
        , mergedSubDefs
        )


typeToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> TvarMap -> Text -> Migration
typeToMigration oldVersion newVersion scope interfaces recursionSet typeNew@(Can.TType moduleName name params) typeOldM tvarMapNew oldValueRef =
  let
    recursionIdentifier :: (ModuleName.Canonical, N.Name)
    recursionIdentifier = (moduleName, name)

    newRecursionSet :: Set.Set (ModuleName.Canonical, N.Name)
    newRecursionSet = Set.insert recursionIdentifier recursionSet

    identifier :: TypeIdentifier
    identifier = asIdentifier typeNew

    typeName :: Text
    typeName = asTypeName typeNew

    kernelError :: Migration
    kernelError =
      case identifier of
        (author, pkg, module_, typeName) ->
          xMigrationNested
            ( T.concat ["-- Kernel error: must not contain kernel type `", show_ typeNew, "` from ", show_ author, "/", show_ pkg, ":", nameToText module_, "\n" ]
            , Set.empty, Map.empty)

    moduleNameRaw :: N.Name
    moduleNameRaw = dropCan moduleName

    withOldParams handler =
      case typeOldM of
        Just typeOld ->
          case typeOld of
            Can.TType oldModuleName oldName paramsOld -> -- @TODO MUST BE SAME COLLECTION TYPE...?
              if oldName == name
                then handler paramsOld
                else unimplemented ("typeToMigration:" <> typeName)
                  ("The old type has changed to a " <> typeName <> ". I need you to write this migration.")
            _ ->
              unimplemented ("typeToMigration:" <> typeName)
                ("The old type has changed to a " <> typeName <> ". I need you to write this migration.")
        Nothing ->
          unimplemented (T.concat ["typeToMigration:", typeName, ":Nothing"])
            ("I couldn't find an old type. I need you to write this migration.")

    migrate1ParamCollection :: Migration
    migrate1ParamCollection =
      withOldParams (\paramsOld ->
        zipFull paramsOld params & (\p ->
          case p of
            (Just p0o,Just p0):[] ->
              let
                (MigrationNested migrate_p0 imps1 subDefs1) =
                  (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMapNew "p0")

                migration = case (isEquivalentElmType name p0o p0) of
                  True -> "" -- No migration necessary
                  False ->
                    if migrate_p0 == ""
                      then T.concat [ typeName, ".map Unimplemented", " -- Type changed from `", typeName, " ", qualifiedTypeName p0o, "` to `", typeName, " ", qualifiedTypeName p0, "`\n" ]
                      else T.concat [ typeName, ".map ", migrate_p0 ]
              in
              xMigrationNested (migration, Set.singleton moduleName, subDefs1)
            _ ->
              error $ T.unpack $ T.concat ["migrate1ParamCollection: impossible multi-param ", typeName, "! Please report this gen issue."]
        )
      )

    migrate2ParamCollection :: (Text -> Text) -> (Text -> Text) -> (Text -> Text -> Text) -> Migration
    migrate2ParamCollection handle1 handle2 handleBoth =
      case typeOldM of
        Just typeOld ->
          case typeOld of
            Can.TType oldModuleName oldName paramsOld -> -- @TODO MUST BE SAME TYPE?
              zipFull paramsOld params & (\p ->
                case p of
                  (Just p0o,Just p0):(Just p1o,Just p1):_ ->
                    let
                      (MigrationNested migrate_p0 imps0 subDefs0) =
                        (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMapNew "p0")
                      (MigrationNested migrate_p1 imps1 subDefs1) =
                        (canToMigration oldVersion newVersion scope interfaces recursionSet p1 (Just p1o) tvarMapNew "p1")
                      (migration, migrationDefs) = case (isEquivalentElmType name p0o p0, isEquivalentElmType name p1o p1) of
                        (True, True)   -> ("", Map.empty) -- No migration necessary
                        (False, True)  -> (handle1 migrate_p0, subDefs0)
                        (True, False)  -> (handle2 migrate_p1, subDefs1)
                        (False, False) -> (handleBoth migrate_p0 migrate_p1, Map.union subDefs0 subDefs1)
                    in
                    xMigrationNested (migration, Set.singleton moduleName, migrationDefs)
                  _ ->
                    error $ concat ["Fatal: impossible !2 param ", T.unpack typeName, " type! Please report this gen issue."]
              )
            _ -> unimplemented (T.concat ["typeToMigration:", typeName])
                  (T.concat ["The old type has changed to a ", typeName, ". I need you to write this migration."])
        Nothing ->
          unimplemented (T.concat ["typeToMigration:", typeName, ":Nothing"])
            ("I couldn't find an old type. I need you to write this migration.")
  in
  if (Set.member recursionIdentifier recursionSet) then
    handleSeenRecursiveType oldVersion newVersion scope identifier interfaces recursionSet typeNew typeOldM tvarMapNew oldValueRef
  else
  debugMigrationIncludes_ "typeToMigration" $
  case identifier of
    ("elm", "core", "String", "String") -> noMigration
    ("elm", "core", "Basics", "Int")    -> noMigration
    ("elm", "core", "Basics", "Float")  -> noMigration
    ("elm", "core", "Basics", "Bool")   -> noMigration
    ("elm", "core", "Basics", "Order")  -> noMigration
    ("elm", "core", "Basics", "Never")  -> noMigration
    ("elm", "core", "Char", "Char")     -> noMigration
    ("elm", "core", "Maybe", "Maybe")   -> migrate1ParamCollection
    ("elm", "core", "List", "List")     -> migrate1ParamCollection
    ("elm", "core", "Array", "Array")   -> migrate1ParamCollection
    ("elm", "core", "Set", "Set")       -> migrate1ParamCollection

    ("elm", "core", "Result", "Result") -> migrate2ParamCollection
      (\m_p0      -> T.concat [ "Result.mapError ", m_p0] )
      (\m_p1      -> T.concat [ "Result.map ", m_p1 ])
      (\m_p0 m_p1 -> T.concat [ "Result.mapError ", m_p0, " |> Result.map ", m_p1 ])

    ("elm", "core", "Dict", "Dict")     -> migrate2ParamCollection
      (\m_p0      -> T.concat [ "Dict.toList |> List.map (Tuple.mapFirst ", m_p0, ") |> Dict.fromList" ])
      (\m_p1      -> T.concat [ "Dict.map (\\k v -> v |> ", m_p1, ")" ])
      (\m_p0 m_p1 -> T.concat [ "Dict.toList |> List.map (Tuple.mapBoth ", m_p0, " ", m_p1, ") |> Dict.fromList" ])

    -- Other core types we can skip migrating
    -- ("elm", "browser", "Browser.Navigation", "Key")   -> noMigration

    -- -- Values backed by JS Kernel types we cannot encode/decode
    -- ("elm", "virtual-dom", "VirtualDom", "Node")      -> kernelError
    -- ("elm", "virtual-dom", "VirtualDom", "Attribute") -> kernelError
    -- ("elm", "virtual-dom", "VirtualDom", "Handler")   -> kernelError
    -- ("elm", "core", "Process", "Id")                  -> kernelError
    -- ("elm", "core", "Platform", "ProcessId")          -> kernelError
    -- ("elm", "core", "Platform", "Program")            -> kernelError
    -- ("elm", "core", "Platform", "Router")             -> kernelError
    -- ("elm", "core", "Platform", "Task")               -> kernelError
    -- ("elm", "core", "Task", "Task")                   -> kernelError
    -- ("elm", "core", "Platform.Cmd", "Cmd")            -> kernelError
    -- ("elm", "core", "Platform.Sub", "Sub")            -> kernelError
    -- ("elm", "json", "Json.Decode", "Decoder")         -> kernelError
    -- ("elm", "json", "Json.Decode", "Value")           -> kernelError
    -- ("elm", "json", "Json.Encode", "Value")           -> kernelError
    -- ("elm", "http", "Http", "Body")                   -> kernelError
    -- ("elm", "http", "Http", "Part")                   -> kernelError
    -- ("elm", "http", "Http", "Expect")                 -> kernelError
    -- ("elm", "http", "Http", "Resolver")               -> kernelError
    -- ("elm", "parser", "Parser", "Parser")             -> kernelError
    -- ("elm", "parser", "Parser.Advanced", "Parser")    -> kernelError
    -- ("elm", "regex", "Regex", "Regex")                -> kernelError

    -- -- Not Kernel, but have functions... should we have them here?
    -- -- @TODO remove once we add test for functions in custom types
    -- ("elm", "url", "Url.Parser", "Parser")               -> kernelError
    -- ("elm", "url", "Url.Parser.Internal", "QueryParser") -> kernelError

    -- Kernel concessions for Frontend Model and Msg
    -- ("elm", "file", "File", "File") -> ("File.File", Set.singleton moduleName, Map.empty)

    -- @TODO improve; These aliases will show up as VirtualDom errors which might confuse users
    -- ("elm", "svg", "Svg", "Svg") -> kernelError
    -- ("elm", "svg", "Svg", "Attribute") -> kernelError

    -- ((ModuleName.Canonical (Pkg.Name "elm" _) (N.Name n)), _) ->
    --   DError $ "❗️unhandled elm type: " <> (T.pack $ show moduleName) <> ":" <> (T.pack $ show name)
    --
    -- ((ModuleName.Canonical (Pkg.Name "elm-explorations" _) (N.Name n)), _) ->
    --   DError $ "❗️unhandled elm-explorations type: " <> (T.pack $ show moduleName) <> ":" <> (T.pack $ show name)

    (author, pkg, module_, typeName) ->
      -- Anything else must not be a core type, recurse to find it


      -- @TODO lift the Maybe handling up so we only ever have a typeOld here
      case typeOldM of
        Just typeOld ->
          case (findTypeDef typeOld interfaces, findTypeDef typeNew interfaces) of
            (Just typeDefOld, Just typeDefNew) ->
              -- @TODO migrateTypeDef needs to be passed tvars!

              let
                tvarMapOld_ = redoTvarMap typeOld typeDefOld
                tvarMapNew_ = redoTvarMap typeNew typeDefNew
              in
              debugHaskellPass "typeToMigration_BOOM" (typeOld, typeNew, typeDefOld, typeDefNew, tvarMapOld_, tvarMapNew_) $
                migrateTypeDef typeDefOld typeDefNew oldVersion newVersion interfaces tvarMapOld_ tvarMapNew_

            (_, Nothing) ->
              unimplemented "typeToMigration" ("Impossible: I came across a `" <> show_ typeNew <> "` reference but couldn't actually load the definition. Please report this.")

            (Nothing, _) ->
              unimplemented "typeToMigration" ("Impossible: I came across a `" <> show_ typeOld <> "` reference but couldn't actually load the definition. Please report this.")


          -- case findDef (moduleNameRaw) name interfaces of
          --   -- @TODO fix old/new refs
          --   Just (Alias moduleNameNew typeNameNew aliasNew) ->
          --     case toAlias typeOld of
          --       Just aliasOld ->
          --         -- @TODO try drop the overly paranoid import merging / insertions
          --         migrateAlias oldVersion newVersion (typeModuleNameCan typeOld) scope identifier name interfaces newRecursionSet aliasOld aliasNew oldValueRef
          --         -- migrateAlias oldVersion newVersion mOld newModule identifier typeNameOld typeNameNew interfaces recursionSet aliasOld aliasNew "old"
          --           & (\(MigrationNested n imports subDefs) ->
          --             xMigrationNested ( n -- <> "<!4>"
          --             , if moduleName /= scope then
          --                 imports & Set.insert moduleName
          --               else
          --                 imports
          --             , subDefs
          --             )
          --           )
          --       Nothing ->
          --         error "todo should not handle maybe here"
          --   Just (Union moduleName tyepNameNew unionNew) ->
          --     migrateUnion typeDefOld oldVersion newVersion scope identifier name interfaces newRecursionSet tvarMapNew unionNew params

          --   Nothing ->
          --     unimplemented "typeToMigration" ("Impossible: I came across a `" <> N.toText typeName <> "` reference but couldn't actually load the definition. Please report this.")

        Nothing -> error "todo should not handle maybe here"


redoTvarMap tipe typeDef =
  let
    names =
      case typeDef of
        (Alias moduleNameOld typeNameOld (Can.Alias tvars tipe_)) -> tvars
        (Union moduleNameOld typeNameOld union) -> Can._u_vars union

    tvarMap =
      case tipe of
        Can.TType moduleName name tvars ->
          zip names tvars
        Can.TAlias moduleName name tvarMap_ aliasType ->
          -- uhhhhh?? this can't be right.
          debugHaskellPass "redoTvarMap_alias" (tipe, typeDef) $
          tvarMap_
  in
  tvarMap



handleSeenRecursiveType :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> TvarMap -> Text -> Migration
handleSeenRecursiveType oldVersion newVersion scope identifier@(author, pkg, newModule, _) interfaces recursionSet tipe@(Can.TType moduleName name params) typeOldM tvarMap oldValueRef =
  -- error "tbc"
  let
      usageMigration :: [Migration]
      usageMigration =
        -- tvarResolveParams
        params
          & fmap (\param -> canToMigration oldVersion newVersion scope interfaces recursionSet param typeOldM tvarMap oldValueRef)

      usageParams :: Text
      usageParams =
        usageMigration
          & fmap migrationDef
          & T.intercalate " "

      usageImports :: Set.Set ModuleName.Canonical
      usageImports =
        usageMigration
          & fmap migrationImports
          & mergeAllImports
          -- & Set.insert oldModuleNameCanonical

      subDefs :: MigrationDefinitions
      subDefs =
        usageMigration
          & fmap migrationTopLevelDefs
          & mergeAllSubDefs

      typeScope :: Text
      typeScope =
        if moduleName == scope then
          ""
        else
          nameToText (dropCan moduleName) <> "."

      typeName :: Text
      typeName = N.toText name

      migrationName :: Text
      migrationName = migrationNameUnderscored newModule oldVersion newVersion name
    in
    xMigrationNested ( if length params > 0 then
        "(" <> migrationName <> " " <> usageParams <> ")" -- <> "<!R>"
      else
        migrationName -- <> "<!R2>"
    , Set.empty
    , subDefs
    )
