{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}

module Lamdera.Evergreen.MigrationGenerator where

import Data.Map (Map)
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.List as List
import qualified Data.Text as T
import qualified Data.Name as N
import NeatInterpolation

import qualified AST.Canonical as Can
import qualified Elm.ModuleName as ModuleName
import qualified Elm.Package as Pkg
import qualified Elm.Interface as Interface
import qualified Data.Utf8 as Utf8

import qualified Ext.Common
import Lamdera
import Lamdera.Types
import qualified Lamdera.Compile
import qualified Ext.ElmFormat
import qualified Ext.Query.Interfaces
import qualified Lamdera.Wire3.Helpers
-- import StandaloneInstances

import Lamdera.Evergreen.MigrationGeneratorHelpers
import Lamdera.Evergreen.MigrationSpecialCases


-- When non-empty, will pretty-print the producer name & definition for the target top-level migration fn name
debugMigrationFn :: Text
debugMigrationFn = ""

-- When non-empty, will pretty-print the producer name & value for an inline migration containing the search text
debugMigrationIncludes :: Text
debugMigrationIncludes = ""

debugMigrationIncludes_ tag migration =
  migration
    & debugHaskellWhen ( debugMigrationIncludes /= ""
      && (
      -- debugMigrationIncludes `T.isInfixOf` migrationDef migration
      -- ||
      (migration
        & migrationTopLevelDefs
        & Map.toList
        & fmap snd
        & filter (\migrationDefinition ->
            migrationDefinition
              & migrations
              & (\v -> debugMigrationIncludes `T.isInfixOf` v)
          )
        & length
        & (\c -> c > 0)
      )
    )
    )
    ("debugMigrationIncludes:" <> tag)


betweenVersions :: CoreTypeDiffs -> Int -> Int -> String -> IO Text
betweenVersions coreTypeDiffs oldVersion newVersion root = do
    let
        paths = ["src/Evergreen/V" <> show oldVersion <> "/Types.elm", "src/Evergreen/V" <> show newVersion <> "/Types.elm"]
        moduleNameString = "Evergreen.V" <> show newVersion <> ".Types"

    Lamdera.Compile.makeDev root paths

    res <- Ext.Common.withProjectRoot root $ do
        interfaces <- Ext.Query.Interfaces.all paths
        case Map.lookup (N.fromChars moduleNameString) interfaces of
          Just interface ->
            generateFor coreTypeDiffs oldVersion newVersion interfaces (interfaces Map.! (N.fromChars $ "Evergreen.V" <> show newVersion <> ".Types"))

          Nothing ->
            error $ "Fatal: could not find the module `" <> moduleNameString <> "`, please report this issue in Discord with your project code."

    Ext.ElmFormat.formatOrPassthrough res
    -- res2 <- Ext.ElmFormat.format res
    -- case res2 of
    --   Right x -> pure x
    --   Left err -> error (T.unpack err)


generateFor :: CoreTypeDiffs -> Int -> Int -> Interfaces -> Interface.Interface -> IO Text
generateFor coreTypeDiffs oldVersion newVersion interfaces iface_Types = do
  let
    moduleName :: ModuleName.Canonical
    moduleName = ModuleName.Canonical (Pkg.Name "author" "project") (N.fromChars $ "Evergreen.V" <> show newVersion <> ".Types")

    coreMigrations :: [(N.Name, Migration)]
    coreMigrations =
      coreTypeDiffs
        & fmap (\(t, oldHash, newHash) ->
            (t, coreTypeMigration (oldHash /= newHash) oldVersion newVersion interfaces moduleName t iface_Types)
        )

    imports :: Text
    imports = coreMigrations
      & fmap snd
      & allImports
      -- a little weird but ensures current version of types, our entry point, is added to final migration imports...
      & Set.insert moduleName
      & importsToText
      & (++) additionalImports
      & List.sort
      & List.nub
      & T.intercalate "\n"

    additionalImports :: [Text]
    additionalImports = ["import Lamdera.Migrations exposing (..)"]

    coreMigrationDefs = coreMigrations & fmap (migrationDef . snd)

    subMigrations = coreMigrations & fmap (migrationTopLevelDefs . snd) & mergeAllSubDefs & allMigrations

    output =
      [ T.concat [ "module Evergreen.Migrate.V", show_ newVersion, " exposing (..)" ]
      , helpfulInformation
      , imports
      ] ++ coreMigrationDefs ++ [ subMigrations ]

  output & T.intercalate "\n\n" & pure



helpfulInformation :: Text
helpfulInformation =
  -- @TODO currently silly hack, but the 'Unimplemented' keyword is naively used to check if there are
  -- any pending migrations... but that means we can't use that word in comments, so we use the utf8 substitute
  -- character trick in the `Unimplementеd` text below which won't match on the basic string search.
  -- In future the better resolution would be to detect the Unimplemented keyword in the AST, so the user
  -- can just comment stuff out but leave it for record.
  [text|
    {-| This migration file was automatically generated by the lamdera compiler.

    It includes:

      - A migration for each of the 6 Lamdera core types that has changed
      - A function named `migrate_ModuleName_TypeName` for each changed/custom type

    Expect to see:

      - `Unimplementеd` values as placeholders wherever I was unable to figure out a clear migration path for you
      - `@NOTICE` comments for things you should know about, i.e. new custom type constructors that won't get any
        value mappings from the old type by default

    You can edit this file however you wish! It won't be generated again.

    See <https://dashboard.lamdera.com/docs/evergreen> for more info.
    -}
  |]


coreTypeMigration :: Bool -> Int -> Int -> Interfaces -> ModuleName.Canonical -> N.Name -> Interface.Interface -> Migration
coreTypeMigration typeDidChange oldVersion newVersion interfaces newModule typeName interface = do
  let
    recursionIdentifier :: (ModuleName.Canonical, N.Name)
    recursionIdentifier = (newModule, typeName)

    recursionSet :: RecursionSet
    recursionSet = Set.singleton recursionIdentifier

    identifier :: TypeIdentifier
    identifier = asIdentifier_ recursionIdentifier

    t :: Text
    t = nameToText typeName

    newModuleName :: Text
    newModuleName = newModule & canModuleName & N.toText

    oldModuleName :: Text
    oldModuleName = asOldModuleName (canModuleName newModule) newVersion oldVersion & nameToText

    migrationWrapper :: Text -> Text
    migrationWrapper migration = do
      T.concat
        ["\n", lowerFirstLetter_ t, " : ", oldModuleName, ".", t, " -> ", migrationTypeForType typeName , " ", newModuleName, ".", t, " ", newModuleName, ".", msgForType typeName, "\n"
        , lowerFirstLetter_ $ nameToText typeName, " old = ", migration
        ]

  if typeDidChange
    then
      case findDef (canModuleName newModule) typeName interfaces of
        Just (Alias alias) -> do
          let
            diffableAlias = aliasToFt oldVersion newVersion newModule identifier typeName interfaces recursionSet alias "old"
            (MigrationNested migrationImpl imps subDefs) = diffableAlias
            migration = T.concat ["\n    ", migrationWrapperForType typeName, " ( ", migrationImpl, " old, Cmd.none )"]
          (MigrationNested (migrationWrapper migration) imps subDefs)

        Just (Union union) -> do
          let
            diffableUnion = migrateUnion oldVersion newVersion newModule identifier typeName interfaces recursionSet [] union []
            (MigrationNested migrationImpl imps subDefs) = diffableUnion
            migration = T.concat ["\n    ", migrationWrapperForType typeName, " ( ", migrationImpl, " old, Cmd.none )"]
          (MigrationNested (migrationWrapper migration) imps subDefs)

        Nothing ->
          error $ concat [ "Tried to generate a migration for core type ", N.toChars typeName, ", but I couldn't find it defined in Types.elm" ]
    else
      (MigrationNested (migrationWrapper (unchangedForType typeName)) Set.empty Map.empty)


-- A top level Custom Type definition i.e. `type Herp = Derp ...`
migrateUnion :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> [(N.Name, Can.Type)] -> Can.Union -> [Can.Type] -> Migration
migrateUnion oldVersion newVersion scope identifier@(author, pkg, newModule, tipe) typeName interfaces recursionSet tvarMap newUnion params =
  let
    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    tipeOld :: Maybe TypeDef
    tipeOld = findDef oldModuleName typeName interfaces
  in
  case tipeOld of
  Nothing        ->
    unimplemented "migrateUnion" ("I couldn't find an old type named `" <> N.toText typeName <> "`. I need you to write this migration.")
  Just (Alias a) ->
    unimplemented "" ("`" <> N.toText typeName <> "` was a type alias, but now it's a custom type. I need you to write this migration.")
  Just (Union oldUnion) ->
    migrateUnion_ author pkg oldUnion newUnion params tvarMap oldVersion newVersion typeName newModule identifier oldModuleName interfaces recursionSet scope


-- catcher x =
--   x


migrateUnion_ :: Pkg.Author -> Pkg.Project -> Can.Union -> Can.Union -> [Can.Type] -> [(N.Name, Can.Type)] -> Int -> Int -> N.Name -> N.Name -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> ModuleName.Canonical -> Migration
migrateUnion_ author pkg oldUnion newUnion params tvarMapOld oldVersion newVersion typeName newModule identifier oldModuleName interfaces recursionSet scope =
  let
    oldModuleNameCanonical :: ModuleName.Canonical
    oldModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) oldModuleName

    newModuleNameCanonical :: ModuleName.Canonical
    newModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) newModule

    tvarMapNew :: [(N.Name, Can.Type)]
    tvarMapNew =
      params
        & zip (Can._u_vars newUnion)

    newTvars :: [Text]
    newTvars =
      params
        & zip (Can._u_vars newUnion)
        & fmap (N.toText . fst)

    oldTvars :: [Text]
    oldTvars =
      params
        & zip (Can._u_vars oldUnion)
        & fmap (N.toText . fst)

    tvarMigrations :: [Migration]
    tvarMigrations =
      -- @TODO do we need to use oldParams here? Maybe not as this is the def migrator, and the actual
      -- value migratons will get caught in the actual constructor migrations?
      zip (tvarResolveParams params tvarMapOld) (tvarResolveParams params tvarMapNew)
        & imap (\i (paramOld, paramNew) ->
          let
            ft@(MigrationNested migration imps subDefs) =
              canToMigration oldVersion newVersion scope interfaces recursionSet paramNew (Just paramOld) tvarMapOld ("p" <> show_ i)
          in
          if migration == "" then
            -- Because paramaterised migrations are passed into functions that expect `v1 -> v2` functions, we
            -- need to pass in a function even if there is no migration necessary, i.e. `String -> String`.
            ft { migrationDef = "identity" }
          else
            ft
        )

    tvarMigrationTextsCombined :: Text
    tvarMigrationTextsCombined =
      tvarMigrations
        & fmap migrationDef
        & parenthesize
        & T.intercalate " "

    tvarMigrationDefinitions :: MigrationDefinitions
    tvarMigrationDefinitions = tvarMigrations & allSubDefs

    localScope :: ModuleName.Canonical
    localScope =
      ModuleName.Canonical (Pkg.Name author pkg) newModule

    oldConstructorsMigrations :: [Migration]
    oldConstructorsMigrations =
      Can._u_alts oldUnion
        & fmap (\(Can.Ctor oldConstructor index int oldParams) ->
          -- For each OLD constructor type param
          genOldConstructorMigration oldModuleName moduleScope typeName interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion newUnion oldUnion oldConstructor oldParams
        )


    -- @TODO is this needed anymore?
    imports :: ElmImports
    imports = oldConstructorsMigrations & allImports

    oldConstructorsMigrationDefinitions :: MigrationDefinitions
    oldConstructorsMigrationDefinitions = oldConstructorsMigrations & allSubDefs

    moduleScope :: Text
    moduleScope = nameToText newModule <> "."

    moduleScopeOld :: Text
    moduleScopeOld = nameToText oldModuleName <> "."

    migrationName :: Text
    migrationName = migrationNameUnderscored newModule oldVersion newVersion typeName

    migration :: Text
    migration = migrationName <> " " <> tvarMigrationTextsCombined -- <> "<!2>"

    paramMigrationPairs = zip oldTvars newTvars

    paramMigrationFnsTypeSig :: [Text]
    paramMigrationFnsTypeSig =
      paramMigrationPairs
        & fmap (\(oldT, newT) -> T.concat [ "(", oldT, "_old -> ", newT, "_new)" ] )

    paramMigrationVars :: Text
    paramMigrationVars =
      paramMigrationPairs
        & fmap (\(oldT, newT) -> T.concat [ "migrate_", oldT ] )
        & T.intercalate " "

    migrationTypeSignature :: Text
    migrationTypeSignature = T.concat
      [ paramMigrationFnsTypeSig & T.intercalate " -> " & suffixIfNonempty " -> "
      , " "
      , oldModuleName & N.toText, ".", typeName & N.toText
      , " "
      , oldTvars & fmap (\tvar -> T.concat [tvar, "_old"]) & T.intercalate " "
      , " -> "
      , newModule & N.toText, ".", typeName & N.toText
      , " "
      , newTvars & fmap (\tvar -> T.concat [tvar, "_new"]) & T.intercalate " "
      ]

    constructorCaseMigrations :: Text
    constructorCaseMigrations =
      oldConstructorsMigrations
        & fmap migrationDef
        & flip (++) (newConstructorWarnings typeName moduleScopeOld newUnion oldUnion newVersion)
        & T.concat

    newConstructorWarnings :: N.Name -> Text -> Can.Union -> Can.Union -> Int -> [Text]
    newConstructorWarnings typeName moduleScope newUnion oldUnion newVersion =
      Can._u_alts newUnion
        & filterMap (\(Can.Ctor newConstructorName index int newParams) -> do
          case Can._u_alts oldUnion & List.find (\(Can.Ctor oldConstructorName _ _ _) ->
                 newConstructorName == oldConstructorName
            ) of
            Nothing ->
              let params =
                    if length newParams > 0
                      then " " <> (T.intercalate " " (fmap asTypeName newParams))
                      else ""
              in
              -- This constructor is missing a match in the old type, warn the user this new constructor exists
              Just $ T.concat [
                "        {- @NOTICE `", N.toText newConstructorName, params, "` was added in V", show_ newVersion, ".\n",
                "        This is just a reminder in case migrating some subset of the old data to this new value was important.\n",
                "        See https://lamdera.com/tips/modified-custom-type for more info.\n",
                "        -}\n"
                ]
            Just _ ->
              -- This constructor has a match in the old type, so skip it
              Nothing
        )
        & (\notices ->
              if length notices > 0 then
                [ "    notices ->\n" <>
                  "        " <> T.concat notices <> "\n" <>
                  "        Unimplemented"
                ]
              else
                []
          )
  in
  debugMigrationIncludes_ "migrateUnion_" $
  case specialCaseMigration identifier of
    Just migrationDef ->
      MigrationNested
        migration
        (Set.fromList [oldModuleNameCanonical, newModuleNameCanonical] <> imports)
        (Map.singleton (newModuleNameCanonical, typeName) migrationDef
            & debugHaskellWhen (debugMigrationFn == migration) "debugMigrationFn:migrateUnion_:specialCased"
            & Map.union tvarMigrationDefinitions
            & Map.union oldConstructorsMigrationDefinitions
        )

    Nothing ->
      xMigrationNested
      ( migration
      , Set.empty
      , (MigrationDefinition
            { imports = Set.fromList [oldModuleNameCanonical, newModuleNameCanonical] <> imports
            , migrations =
              -- Map.singleton migrationName $
              T.concat
                [ migrationName, " : ", migrationTypeSignature, "\n"
                , [ migrationName, paramMigrationVars, " old =\n" ] & T.intercalate " "
                , "  case old of\n"
                , constructorCaseMigrations
                ]
            }
            & debugHaskellWhen (debugMigrationFn == migrationName) "debugMigrationFn:migrateUnion_"
            & Map.singleton (newModuleNameCanonical, typeName)
          )
          & Map.union tvarMigrationDefinitions
          & Map.union oldConstructorsMigrationDefinitions
      )


genOldConstructorMigration :: N.Name -> Text -> N.Name -> Interfaces -> [(N.Name, Can.Type)] -> [(N.Name, Can.Type)] -> RecursionSet -> ModuleName.Canonical -> Int -> Int -> Can.Union -> Can.Union -> N.Name -> [Can.Type] -> Migration
genOldConstructorMigration oldModuleName moduleScope typeName interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion newUnion oldUnion oldConstructorName oldParams =
  let
    newCtorM :: Maybe Can.Ctor
    newCtorM = Can._u_alts newUnion & List.find (\(Can.Ctor newConstructorName _ _ _) -> newConstructorName == oldConstructorName )

    migration_ :: Migration
    migration_ =
      case newCtorM of
      Just (Can.Ctor newConstructorName _ _ newParams) ->
        let
            paramMigrations :: [Migration]
            paramMigrations =
              zipFull oldParams newParams
                & imap (\i (paramOldM, paramNewM) ->
                  migrateParam i paramOldM paramNewM interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion
                )

            fullMigration =
              xMigrationNested ( if List.length oldParams > 0 then
                  let migration =
                        paramMigrations
                          & fmap migrationDef
                          & (\paramMigrations -> T.concat [ moduleScope, N.toText newConstructorName, " ", (paramMigrations & T.intercalate " ") ])
                  in
                  T.concat
                      [ "    ", N.toText oldModuleName, ".", N.toText oldConstructorName, " ", (imap (\i _ -> "p" <> show_ i) oldParams & T.intercalate " ")
                      , " -> \n"
                      , migration & T.lines & fmap (\v -> T.concat ["        ", v ]) & T.unlines
                      , "\n"
                      ]
                else
                  T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructorName, " -> ", moduleScope, N.toText newConstructorName, "\n"]
              , paramMigrations
                  & fmap migrationImports
                  & mergeAllImports
              , paramMigrations
                  & fmap migrationTopLevelDefs
                  & mergeAllSubDefs
              )
        in
        fullMigration

      Nothing ->
        let
          oldConstructorRemovedMessage :: Text
          oldConstructorRemovedMessage =
            T.concat [
              " ->\n",
              "           {- `", N.toText oldConstructorName, "` was removed or renamed in V", show_ newVersion, " so I couldn't figure out how to migrate it.\n",
              "           I need you to decide what happens to this ", N.toText oldModuleName, ".", N.toText oldConstructorName, " value in a migration.\n",
              "           See https://lamdera.com/tips/modified-custom-type for more info.\n",
              "           -}\n",
              "           Unimplemented\n"
            ]
        in
        xMigrationNested ( -- No old constructor with same name, so this is a new/renamed constructor
          if List.length oldParams > 0
            then
              T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructorName, " ", (imap (\i _ -> "p" <> show_ i) oldParams & T.intercalate " "), oldConstructorRemovedMessage]
            else
              T.concat ["    ", N.toText oldModuleName, ".", N.toText oldConstructorName, oldConstructorRemovedMessage]
        , Set.empty
        , Map.empty
        )
  in
  migration_


migrateParam :: Int -> Maybe Can.Type -> Maybe Can.Type -> Interfaces -> [(N.Name, Can.Type)] -> [(N.Name, Can.Type)] -> RecursionSet -> ModuleName.Canonical -> Int -> Int -> Migration
migrateParam i paramOldM paramNewM interfaces tvarMapOld tvarMapNew recursionSet localScope newVersion oldVersion =
  -- debugHaskell "migrateParam" $
  case (paramOldM, paramNewM) of
    (Just paramOld, Just paramNew) ->
      let ft@(MigrationNested migration imps subDefs) =
            canToMigration oldVersion newVersion localScope interfaces recursionSet paramNew (Just paramOld) tvarMapOld ("p" <> show_ i)

          appliedMigration =
            if isTvar paramOld then
              case paramOld of
                Can.TVar name ->
                  xMigrationNested (T.concat ["( migrate_", N.toText name, " p", show_ i, ")"], imps, subDefs)
                _ ->
                  error "impossible:appliedMigration tvar /= tvar"
            else if isEquivalentElmType "External.Paramed" (tvarResolveParam tvarMapOld paramOld) (tvarResolveParam tvarMapNew paramNew) then
              -- debugHaskellPass "thethingis" (
              --     (tvarResolveParam tvarMapOld paramOld)
              --   , (tvarResolveParam tvarMapNew paramNew)
              --   ) $
              xMigrationNested (T.concat ["p", show_ i], Set.empty, Map.empty)
            else if isAnonymousRecord paramOld then
              ft
            else if isUserDefinedType_ paramOld then
              xMigrationNested (T.concat ["(p", show_ i, " |> ", migration, ")"], imps, subDefs)
            else
              xMigrationNested (T.concat ["(p", show_ i, " |> ", migration, ")"], imps, subDefs)
      in
      appliedMigration

    (Just paramOld, Nothing) ->
      unimplemented "migrateParam:noNew" ("Warning: old variant didn't get mapped to anything, check this is what you want")

    (Nothing, Just paramNew) ->
      unimplemented "migrateParam:noOld" ("This new variant needs to be initialised")

    _ -> error "impossible, zip produced a value without any contents"


-- A top level Alias definition i.e. `type alias ...`
aliasToFt :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> Can.Alias -> Text -> Migration
aliasToFt oldVersion newVersion scope identifier@(author, pkg, newModule, _) typeName interfaces recursionSet alias@(Can.Alias tvars tipe) oldValueRef =
  let
    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    tipeOldM :: Maybe TypeDef
    tipeOldM = findDef oldModuleName typeName interfaces
  in
  case tipeOldM of
    Nothing               ->
      unimplemented "aliasToFt:Nothing" ("I couldn't find an old type named `" <> N.toText typeName <> "`. I need you to write this migration.")
    Just (Union oldUnion) ->
      unimplemented "" ("`" <> N.toText typeName <> "` was a custom type, but now it's a type alias. I need you to write this migration.")
    Just (Alias aliasOld@(Can.Alias tvarsOld tipeOld)) ->
      migrateAlias oldVersion newVersion scope identifier typeName interfaces recursionSet alias aliasOld oldModuleName oldValueRef


-- A top level Alias definition i.e. `type alias ...`
migrateAlias :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> N.Name -> Interfaces -> RecursionSet -> Can.Alias -> Can.Alias -> N.Name -> Text -> Migration
migrateAlias oldVersion newVersion scope identifier@(author, pkg, newModule, typeNameNew) typeName interfaces recursionSet (Can.Alias tvarsNew tipe) (Can.Alias tvarsOld tipeOld) oldModuleName oldValueRef =
  let
    (MigrationNested subt imps subDefs) = canToMigration oldVersion newVersion scope interfaces recursionSet tipe (Just tipeOld) [] oldValueRef

    oldModuleNameCanonical :: ModuleName.Canonical
    oldModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) oldModuleName

    newModuleNameCanonical :: ModuleName.Canonical
    newModuleNameCanonical = ModuleName.Canonical (Pkg.Name author pkg) newModule

    typeScope =
      if moduleName == scope then
        ""
      -- else if isUserType identifier then
      --   nameToText newModule <> "."
      else
        T.concat [nameToText newModule, "."]

    moduleName = (ModuleName.Canonical (Pkg.Name author pkg) newModule)

    migration =
      if tipe == tipeOld then
        "ModelUnchanged"
      else
        subt

    newModuleName = newModule & N.toText

    migrationName_ :: Text
    migrationName_ = migrationNameUnderscored newModule oldVersion newVersion typeName

    applyOldValueIfNotRecord =
      if isRecord tipe then
        ""
      else
        T.concat [oldValueRef, " |> "]

    -- !x = debugHaskell "applyOldValueIfNotRecord" (isRecord tipe, tipe)

  in
  debugMigrationIncludes_ "migrateAlias" $
  case specialCaseMigration identifier of
    Just migrationDef ->
      MigrationNested
        migrationName_
        (Set.fromList [oldModuleNameCanonical, newModuleNameCanonical] <> imps)
        (migrationDef
          & debugHaskellWhen (debugMigrationFn == migrationName_) "debugMigrationFn:migrateAlias:specialCased"
          & Map.singleton (newModuleNameCanonical, typeNameNew)
          & Map.union subDefs
        )
    Nothing ->
      xMigrationNested
      ( migrationName_
      , Set.fromList [oldModuleNameCanonical, newModuleNameCanonical]
      , (MigrationDefinition
            { imports = imps
            , migrations =
                -- Map.singleton (lowerFirstLetter_ $ nameToText typeName) $
                T.concat
                  ["\n", migrationName_, " : ", nameToText oldModuleName, ".", nameToText typeName, " -> ", newModuleName, ".", nameToText typeName, "\n"
                  , migrationName_, " ", oldValueRef, " = ", applyOldValueIfNotRecord, migration
                  ]
            }
            & debugHaskellWhen (debugMigrationFn == migrationName_) "debugMigrationFn:migrateAlias"
            & Map.singleton (newModuleNameCanonical, typeNameNew)
          )
          & Map.union subDefs
      )


canToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
canToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef =
  debugMigrationIncludes_ "canToMigration" $
  -- let !x = debugHaskell "canToMigration" (tipeOldM, tipe)
  -- in
  case tipe of
    Can.TType moduleName name params ->
      typeToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef

    Can.TAlias moduleName name tvarMap_ aliasType ->
      canAliasToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef

    Can.TRecord newFields isPartial ->
      recordToMigration oldVersion newVersion scope interfaces recursionSet tipe tipeOldM tvarMap oldValueRef

    Can.TTuple t1 t2 mt3 ->
      let
        (MigrationNested subt imps subDefs) =
          canToMigration oldVersion newVersion scope interfaces recursionSet t1 tipeOldM tvarMap oldValueRef
        (MigrationNested subt2 imps2 subDefs2) =
          canToMigration oldVersion newVersion scope interfaces recursionSet t2 tipeOldM tvarMap oldValueRef
      in
      case mt3 of
        Just t3 ->
          let
            (MigrationNested subt3 imps3 subDefs3) =
              canToMigration oldVersion newVersion scope interfaces recursionSet t3 tipeOldM tvarMap oldValueRef
          in
          xMigrationNested (T.concat ["(", subt, ", ", subt2, ", ", subt3, ")"], mergeAllImports [imps,imps2,imps3], mergeAllSubDefs [subDefs,subDefs2,subDefs3])

        Nothing ->
          xMigrationNested (T.concat ["(", subt, ", ", subt2, ")"], imps <> imps2, Map.union subDefs subDefs2)

    Can.TUnit ->
      xMigrationNested ("()", Set.empty, Map.empty)

    Can.TVar name ->
      xMigrationNested ("migrate_" <> N.toText name, Set.empty, Map.empty)

    Can.TLambda _ _ ->
      error "Fatal: impossible function type! Please report this gen issue."


canAliasToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
canAliasToMigration oldVersion newVersion scope interfaces recursionSet tipeNew@(Can.TAlias moduleNameNew typeNameNew tvarMapNew aliasTypeNew) tipeOldM tvarMap oldValueRef =
  let
    module_ =
      case moduleNameNew of
        (ModuleName.Canonical (Pkg.Name author pkg) module_) -> module_

    newModule = module_

    identifier = asIdentifier_ (moduleNameNew, typeNameNew)

    oldModuleName :: N.Name
    oldModuleName = asOldModuleName newModule newVersion oldVersion

    oldModule :: ModuleName.Canonical
    oldModule = asOldModule newModule newVersion oldVersion
  in
  debugMigrationIncludes_ "canAliasToMigration" $
  case aliasTypeNew of
    Can.Holey cType ->
      case tipeOldM of
        Just (tipeOld@(Can.TAlias moduleNameOld typeNameOld tvarMapOld aliasType)) ->
          let
            usageParamSubDefs :: [Migration]
            usageParamSubDefs =
              zip tvarMapOld tvarMapNew
                & fmap (\((nOld, paramTypeOld), (nNew, paramTypeNew)) ->
                  canToMigration oldVersion newVersion scope interfaces recursionSet paramTypeNew (Just paramTypeOld) tvarMapNew oldValueRef
                )

            usageParamNames :: Text
            usageParamNames =
              usageParamSubDefs
                & fmap migrationDef
                & T.intercalate " "

            newTvars :: [Text]
            newTvars = tvarMapNew & fmap (N.toText . fst)

            oldTvars :: [Text]
            oldTvars = tvarMapOld & fmap (N.toText . fst)

            (MigrationNested subt imps subDefs) :: Migration =
              let
                paramPairs = zipWith (\(n1,t1) (n2,t2) -> (n1, t1, t2)) tvarMapOld tvarMapNew
                res = canToMigration oldVersion newVersion moduleNameNew interfaces recursionSet cType (Just tipeOld) tvarMapOld oldValueRef
              in
              res

            typeScope =
              if moduleNameNew == scope then
                ""
              -- else if isUserType identifier then
              --   nameToText module_ <> "."
              else
                T.concat [nameToText module_, "."]

            debugIden = "" -- <> "<ah>"

            migrationName :: Text
            migrationName = migrationNameUnderscored newModule oldVersion newVersion typeNameNew

            paramMigrationPairs = zip oldTvars newTvars

            paramMigrationFnsTypeSig :: [Text]
            paramMigrationFnsTypeSig =
              paramMigrationPairs
                & fmap (\(oldT, newT) -> T.concat [ "(", oldT, "_old -> ", newT, "_new)" ] )

            paramMigrationVars :: Text
            paramMigrationVars =
              paramMigrationPairs
                & fmap (\(oldT, newT) -> T.concat [ "migrate_", oldT ] )
                & T.intercalate " "

            oldType = T.concat [oldModuleName & N.toText, ".", typeNameNew & N.toText]
            newType = T.concat [newModule & N.toText, ".", typeNameNew & N.toText]

            migrationTypeSignature :: Text
            migrationTypeSignature = T.concat
              [ paramMigrationFnsTypeSig & T.intercalate " -> " & suffixIfNonempty " -> "
              , " "
              , oldType
              , " "
              , oldTvars & fmap (\tvar -> T.concat [tvar, "_old"]) & T.intercalate " "
              , " -> "
              , newType
              , " "
              , newTvars & fmap (\tvar -> T.concat [tvar, "_new"]) & T.intercalate " "
              ]

            applyOldValueIfNotRecord =
              if isRecord cType then
                ""
              else
                T.concat [oldValueRef, " |> "]

            typeDef =
              if isUserDefinedType_ cType then
                T.concat
                  [ migrationName, " : ", migrationTypeSignature, "\n"
                  , migrationName, " ", paramMigrationVars, " ", oldValueRef, " = ", applyOldValueIfNotRecord, subt
                  ]

              else
                -- T.concat [ "-- no migration for primitive: " <> N.toText name ]
                "-- oopsie\n"

            migration =
              if length tvarMapNew > 0 then
                T.concat ["(", migrationName, " ", usageParamNames, ")"] -- <> "<!2>"
              else
                migrationName -- <> "<!3>"
          in
            xMigrationNested ( migration , Set.empty,
              (Map.singleton (moduleNameNew, typeNameNew) $
                MigrationDefinition
                  { imports = Set.fromList [moduleNameNew, moduleNameOld]
                  , migrations = typeDef
                  }
              )
                & Map.union subDefs
                & Map.union (mergeAllSubDefs (fmap migrationTopLevelDefs usageParamSubDefs))
             )

        Just tipeOld ->
          -- The old type is not an alias, but the new type is. Is this the right treatment?
          unimplemented ""
            ("`" <> N.toText typeNameNew <> "` was a concrete type, but now it's a type alias. I need you to write this migration." )

        Nothing ->
          unimplemented "canAliasToMigration" (T.concat ["I couldn't find an old type named `", N.toText oldModuleName, ".", N.toText typeNameNew, "`. I need you to write this migration.\n" ])

    Can.Filled cType ->
      -- @TODO hypothesis...
      -- If an alias is filled, then it can't have any open holes within it either?
      -- So we can take this opportunity to reset tvars to reduce likeliness of naming conflicts?
      let
        (MigrationNested subt imps subDefs) = canToMigration oldVersion newVersion moduleNameNew interfaces recursionSet cType tipeOldM [] oldValueRef
        debugIden = "" -- <> "<af>"
      in
      xMigrationNested (
        debugIden <> "🔴" <>
        if module_ == (canModuleName scope) then
          N.toText typeNameNew
        else if isUserType identifier then
          T.concat [nameToText module_, "."]
        else
          T.concat [nameToText module_, ".", N.toText typeNameNew]
      , imps
      , subDefs
      )


recordToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
recordToMigration oldVersion newVersion scope interfaces recursionSet tipe@(Can.TRecord newFields isPartial) tipeOldM tvarMap oldValueRef =
  debugMigrationIncludes_ "recordToMigration" $
  case isPartial of
    Just whatIsThis ->
      xMigrationNested ("ERROR TRecord, please report this!", Set.empty, Map.empty)
      -- DError "must not contain partial records"

    Nothing ->
      let
        fieldMapOld :: Map N.Name Can.FieldType
        fieldMapOld =
          case tipeOldM of
            Just tipeOld ->
              case Lamdera.Wire3.Helpers.resolveFieldMap tipeOld tvarMap of
                Just fields -> fields
                Nothing -> Map.empty
            _ -> Map.empty

        fieldMigrations :: [(Text, Migration)]
        fieldMigrations =
          newFields
            & Map.toList
            -- Restore user's field code-ordering to keep types looking familiar
            & List.sortOn (\(name, (Can.FieldType index ftipe)) -> index)
            & fmap (\(name, (Can.FieldType index ftipe)) ->
                case Map.lookup name fieldMapOld of
                  Just (Can.FieldType index_ ftipeOld) ->
                    if isEquivalentElmType name ftipeOld ftipe then
                      (N.toText name
                      , xMigrationNested
                        ( T.concat[ oldValueRef, ".", N.toText name]
                        , Set.empty
                        , Map.empty
                        )
                      )
                    else
                      -- debugHaskellPassDiffWhen (name == "unchangedAllTypes") "these types are unequal" (ftipeOld, ftipe) $
                      if isAnonymousRecord ftipe
                        then
                          -- In order to deal with anonymous records inline, we have to change
                          -- the name of the value to avoid shadowing the `old.` ref.
                          let
                            readMaybeInt :: Text -> Maybe Int
                            readMaybeInt = readMaybeText

                            -- For every additional anonymous nesting, bump the reference number
                            recname :: Text
                            recname =
                              case oldValueRef of
                                "old" -> "rec"
                                _ ->
                                  oldValueRef
                                    & T.replace "rec" ""
                                    & readMaybeInt
                                    & withDefault (0 :: Int)
                                    & (+) 1
                                    & show_
                                    & (<>) "rec"

                            (MigrationNested st imps subDefs) = recordToMigration oldVersion newVersion scope interfaces recursionSet ftipe (Just ftipeOld) tvarMap recname
                          in
                          ( N.toText name
                          , xMigrationNested
                            ( T.concat [oldValueRef, ".", N.toText name, " |> (\\", recname, " -> ", st, ")"], imps, subDefs)
                          )
                        else
                          let
                            (MigrationNested st imps subDefs) =
                              canToMigration oldVersion newVersion scope interfaces recursionSet ftipe (Just (ftipeOld)) tvarMap oldValueRef
                          in
                          ( N.toText name
                          , xMigrationNested ( T.concat [oldValueRef, ".", N.toText name, " |> ", st ], imps, subDefs)
                          )

                  Nothing ->
                    -- This field did not exist in the old version. We need an init!
                    let (MigrationNested st imps ft) = canToMigration oldVersion newVersion scope interfaces recursionSet ftipe Nothing tvarMap oldValueRef
                    in
                    ( N.toText name, xMigrationNested (T.concat["Unimplemented -- Type `", qualifiedTypeName ftipe, "` was added in V", show_ newVersion, ". I need you to set a default value."], imps, ft) )
            )
            & (\v -> v ++ missingFields)

        missingFields :: [(Text, Migration)]
        missingFields =
          fieldMapOld
            & Map.toList
            & filterMap (\(name, (Can.FieldType index tipe)) ->
              case Map.lookup name newFields of
                Just (Can.FieldType index_ tipeOld) ->
                  Nothing
                Nothing ->
                  Just ( N.toText name
                       , unimplemented ("recordToMigration:" <> qualifiedTypeName tipe)
                          ( T.concat["Field of type `", qualifiedTypeName tipe, "` was removed in V", show_ newVersion
                          , ". I need you to do something with the `", oldValueRef, ".", N.toText name, "` value if you wish to keep the data, then remove this line."]
                          )
                  )
            )

        fieldsFormatted :: Text
        fieldsFormatted =
          fieldMigrations
            & fmap (\(fieldname, (MigrationNested st imps ft)) -> fieldname <> " = " <> st)
            & T.intercalate "\n    , "

        imports :: ElmImports
        imports =
          fieldMigrations
            & foldl (\acc (name, (MigrationNested st imps ft)) -> acc <> imps) Set.empty

        mergedSubDefs :: MigrationDefinitions
        mergedSubDefs = fieldMigrations & fmap snd & allSubDefs

      in
      xMigrationNested
        ( "\n    { " <> fieldsFormatted <> "\n    }"
        , imports
        , mergedSubDefs
        )


typeToMigration :: Int -> Int -> ModuleName.Canonical -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
typeToMigration oldVersion newVersion scope interfaces recursionSet tipe@(Can.TType moduleName name params) tipeOldM tvarMap oldValueRef =
  let
    recursionIdentifier :: (ModuleName.Canonical, N.Name)
    recursionIdentifier = (moduleName, name)

    newRecursionSet :: Set.Set (ModuleName.Canonical, N.Name)
    newRecursionSet = Set.insert recursionIdentifier recursionSet

    identifier :: TypeIdentifier
    identifier = asIdentifier tipe

    typeName :: Text
    typeName = asTypeName tipe

    kernelError :: Migration
    kernelError =
      case identifier of
        (author, pkg, module_, typeName) ->
          xMigrationNested
            ( T.concat ["-- Kernel error: must not contain kernel type `", show_ tipe, "` from ", show_ author, "/", show_ pkg, ":", nameToText module_, "\n" ]
            , Set.empty, Map.empty)

    moduleNameRaw :: N.Name
    moduleNameRaw = canModuleName moduleName

    withOldParams handler =
      case tipeOldM of
        Just tipeOld ->
          case tipeOld of
            Can.TType oldModuleName oldName paramsOld -> -- @TODO MUST BE SAME COLLECTION TYPE...?
              if oldName == name
                then handler paramsOld
                else unimplemented ("typeToMigration:" <> typeName)
                  ("The old type has changed to a " <> typeName <> ". I need you to write this migration.")
            _ ->
              unimplemented ("typeToMigration:" <> typeName)
                ("The old type has changed to a " <> typeName <> ". I need you to write this migration.")
        Nothing ->
          unimplemented (T.concat ["typeToMigration:", typeName, ":Nothing"])
            ("I couldn't find an old type. I need you to write this migration.")

    migrate1ParamCollection :: Migration
    migrate1ParamCollection =
      withOldParams (\paramsOld ->
        zipFull paramsOld params & (\p ->
          case p of
            (Just p0o,Just p0):[] ->
              let
                (MigrationNested migration_p1 imps1 subDefs1) =
                  (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMap "p0")

                migration = case (isEquivalentElmType name p0o p0) of
                  True -> "" -- No migration necessary
                  False ->
                    if migration_p1 == ""
                      then T.concat [ typeName, ".map Unimplemented", " -- Type changed from `", typeName, " ", qualifiedTypeName p0o, "` to `", typeName, " ", qualifiedTypeName p0, "`\n" ]
                      else T.concat [ typeName, ".map ", migration_p1 ]
              in
              xMigrationNested (migration, Set.singleton moduleName, subDefs1)
            _ ->
              error $ T.unpack $ T.concat ["migrate1ParamCollection: impossible multi-param ", typeName, "! Please report this gen issue."]
        )
      )

    migrate2ParamCollection :: (Text -> Text) -> (Text -> Text) -> (Text -> Text -> Text) -> Migration
    migrate2ParamCollection handle1 handle2 handleBoth =
      case tipeOldM of
        Just tipeOld ->
          case tipeOld of
            Can.TType oldModuleName oldName paramsOld -> -- @TODO MUST BE SAME TYPE?
              zipFull paramsOld params & (\p ->
                case p of
                  (Just p0o,Just p0):(Just p1o,Just p1):_ ->
                    let
                      (MigrationNested migrate_p0 imps0 subDefs0) =
                        (canToMigration oldVersion newVersion scope interfaces recursionSet p0 (Just p0o) tvarMap "p0")
                      (MigrationNested migrate_p1 imps1 subDefs1) =
                        (canToMigration oldVersion newVersion scope interfaces recursionSet p1 (Just p1o) tvarMap "p1")
                      (migration, migrationDefs) = case (isEquivalentElmType name p0o p0, isEquivalentElmType name p1o p1) of
                        (True, True)   -> ("", Map.empty) -- No migration necessary
                        (False, True)  -> (handle1 migrate_p0, subDefs0)
                        (True, False)  -> (handle2 migrate_p1, subDefs1)
                        (False, False) -> (handleBoth migrate_p0 migrate_p1, Map.union subDefs0 subDefs1)
                    in
                    xMigrationNested (migration, Set.singleton moduleName, migrationDefs)
                  _ ->
                    error $ concat ["Fatal: impossible !2 param ", T.unpack typeName, " type! Please report this gen issue."]
              )
            _ -> unimplemented (T.concat ["typeToMigration:", typeName])
                  (T.concat ["The old type has changed to a ", typeName, ". I need you to write this migration."])
        Nothing ->
          unimplemented (T.concat ["typeToMigration:", typeName, ":Nothing"])
            ("I couldn't find an old type. I need you to write this migration.")
  in
  if (Set.member recursionIdentifier recursionSet) then
    handleSeenRecursiveType oldVersion newVersion scope identifier interfaces recursionSet tipe tipeOldM tvarMap oldValueRef
  else
  debugMigrationIncludes_ "typeToMigration" $
  case identifier of
    ("elm", "core", "String", "String") -> noMigration
    ("elm", "core", "Basics", "Int")    -> noMigration
    ("elm", "core", "Basics", "Float")  -> noMigration
    ("elm", "core", "Basics", "Bool")   -> noMigration
    ("elm", "core", "Basics", "Order")  -> noMigration
    ("elm", "core", "Basics", "Never")  -> noMigration
    ("elm", "core", "Char", "Char")     -> noMigration
    ("elm", "core", "Maybe", "Maybe")   -> migrate1ParamCollection
    ("elm", "core", "List", "List")     -> migrate1ParamCollection
    ("elm", "core", "Array", "Array")   -> migrate1ParamCollection
    ("elm", "core", "Set", "Set")       -> migrate1ParamCollection

    ("elm", "core", "Result", "Result") -> migrate2ParamCollection
      (\m_p0      -> T.concat [ "Result.mapError ", m_p0] )
      (\m_p1      -> T.concat [ "Result.map ", m_p1 ])
      (\m_p0 m_p1 -> T.concat [ "Result.mapError ", m_p0, " |> Result.map ", m_p1 ])

    ("elm", "core", "Dict", "Dict")     -> migrate2ParamCollection
      (\m_p0      -> T.concat [ "Dict.toList |> List.map (Tuple.mapFirst ", m_p0, ") |> Dict.fromList" ])
      (\m_p1      -> T.concat [ "Dict.map (\\k v -> v |> ", m_p1, ")" ])
      (\m_p0 m_p1 -> T.concat [ "Dict.toList |> List.map (Tuple.mapBoth ", m_p0, " ", m_p1, ") |> Dict.fromList" ])

    -- Other core types we can skip migrating
    ("elm", "browser", "Browser.Navigation", "Key")   -> noMigration

    -- Values backed by JS Kernel types we cannot encode/decode
    ("elm", "virtual-dom", "VirtualDom", "Node")      -> kernelError
    ("elm", "virtual-dom", "VirtualDom", "Attribute") -> kernelError
    ("elm", "virtual-dom", "VirtualDom", "Handler")   -> kernelError
    ("elm", "core", "Process", "Id")                  -> kernelError
    ("elm", "core", "Platform", "ProcessId")          -> kernelError
    ("elm", "core", "Platform", "Program")            -> kernelError
    ("elm", "core", "Platform", "Router")             -> kernelError
    ("elm", "core", "Platform", "Task")               -> kernelError
    ("elm", "core", "Task", "Task")                   -> kernelError
    ("elm", "core", "Platform.Cmd", "Cmd")            -> kernelError
    ("elm", "core", "Platform.Sub", "Sub")            -> kernelError
    ("elm", "json", "Json.Decode", "Decoder")         -> kernelError
    ("elm", "json", "Json.Decode", "Value")           -> kernelError
    ("elm", "json", "Json.Encode", "Value")           -> kernelError
    ("elm", "http", "Http", "Body")                   -> kernelError
    ("elm", "http", "Http", "Part")                   -> kernelError
    ("elm", "http", "Http", "Expect")                 -> kernelError
    ("elm", "http", "Http", "Resolver")               -> kernelError
    ("elm", "parser", "Parser", "Parser")             -> kernelError
    ("elm", "parser", "Parser.Advanced", "Parser")    -> kernelError
    ("elm", "regex", "Regex", "Regex")                -> kernelError

    -- Not Kernel, but have functions... should we have them here?
    -- @TODO remove once we add test for functions in custom types
    ("elm", "url", "Url.Parser", "Parser")               -> kernelError
    ("elm", "url", "Url.Parser.Internal", "QueryParser") -> kernelError

    -- Kernel concessions for Frontend Model and Msg
    -- ("elm", "file", "File", "File") -> ("File.File", Set.singleton moduleName, Map.empty)

    -- @TODO improve; These aliases will show up as VirtualDom errors which might confuse users
    -- ("elm", "svg", "Svg", "Svg") -> kernelError
    -- ("elm", "svg", "Svg", "Attribute") -> kernelError

    -- ((ModuleName.Canonical (Pkg.Name "elm" _) (N.Name n)), _) ->
    --   DError $ "❗️unhandled elm type: " <> (T.pack $ show moduleName) <> ":" <> (T.pack $ show name)
    --
    -- ((ModuleName.Canonical (Pkg.Name "elm-explorations" _) (N.Name n)), _) ->
    --   DError $ "❗️unhandled elm-explorations type: " <> (T.pack $ show moduleName) <> ":" <> (T.pack $ show name)

    (author, pkg, module_, typeName) ->
      -- Anything else must not be a core type, recurse to find it

      let handleUnion union =
            migrateUnion oldVersion newVersion scope identifier name interfaces newRecursionSet tvarMap union params

          handleAlias alias =
            -- @TODO try drop the overly paranoid import merging / insertions
            aliasToFt oldVersion newVersion scope identifier name interfaces newRecursionSet alias oldValueRef
              & (\(MigrationNested n imports subDefs) ->
                xMigrationNested ( n -- <> "<!4>"
                , if moduleName /= scope then
                    imports & Set.insert moduleName
                  else
                    imports
                , subDefs
                )
              )
      in
      case findDef (moduleNameRaw) name interfaces of
        Just (Alias alias) -> handleAlias alias
        Just (Union union) -> handleUnion union
        Nothing ->
          unimplemented "typeToMigration" ("I couldn't find an old type named `" <> N.toText typeName <> "`. I need you to write this migration.")


handleSeenRecursiveType :: Int -> Int -> ModuleName.Canonical -> TypeIdentifier -> Interfaces -> RecursionSet -> Can.Type -> Maybe Can.Type -> [(N.Name, Can.Type)] -> Text -> Migration
handleSeenRecursiveType oldVersion newVersion scope identifier@(author, pkg, newModule, _) interfaces recursionSet tipe@(Can.TType moduleName name params) tipeOldM tvarMap oldValueRef =
  -- error "tbc"
  let
      usageMigration :: [Migration]
      usageMigration =
        -- tvarResolveParams
        params
          & fmap (\param -> canToMigration oldVersion newVersion scope interfaces recursionSet param tipeOldM tvarMap oldValueRef)

      usageParams :: Text
      usageParams =
        usageMigration
          & fmap migrationDef
          & T.intercalate " "

      usageImports :: Set.Set ModuleName.Canonical
      usageImports =
        usageMigration
          & fmap migrationImports
          & mergeAllImports
          -- & Set.insert oldModuleNameCanonical

      subDefs :: MigrationDefinitions
      subDefs =
        usageMigration
          & fmap migrationTopLevelDefs
          & mergeAllSubDefs

      typeScope :: Text
      typeScope =
        if moduleName == scope then
          ""
        else
          nameToText (canModuleName moduleName) <> "."

      typeName :: Text
      typeName = N.toText name

      migrationName :: Text
      migrationName = migrationNameUnderscored newModule oldVersion newVersion name
    in
    xMigrationNested ( if length params > 0 then
        "(" <> migrationName <> " " <> usageParams <> ")" -- <> "<!R>"
      else
        migrationName -- <> "<!R2>"
    , Set.empty
    , subDefs
    )
